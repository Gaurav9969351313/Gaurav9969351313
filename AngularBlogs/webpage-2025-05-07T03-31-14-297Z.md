# Angular Application Security. Security is a top priority for Angular… | by Piyali Das | Medium

# Angular Application Security

[

![Piyali Das](https://miro.medium.com/v2/resize:fill:40:40/1*Lw8C8pu0QC2ZxW0oJ8jAqA.jpeg)





](/@piyalidas.it?source=post_page---byline--02da7669f476---------------------------------------)

[Piyali Das](/@piyalidas.it?source=post_page---byline--02da7669f476---------------------------------------)

Follow

11 min read

·

Nov 3, 2024

273

1

Listen

Share

More

Security is a top priority for Angular applications, as security breaches can result in data leaks, unauthorized access, and loss of user trust. Angular applications handle sensitive user data and perform critical functions, robust protection. Angular includes built-in security features to address common vulnerabilities like XSS and CSRF, equipping developers with tools to safeguard their applications and users effectively.

<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fstackblitz.com%2Fedit%2Fstackblitz-starters-22fu8pz8%3Fembed%3D1%26file%3Dsrc%252Fapp.component.html&amp;display_name=StackBlitz&amp;url=https%3A%2F%2Fstackblitz.com%2Fedit%2Fstackblitz-starters-22fu8pz8%3Fembed%3D1%26file%3Dsrc%252Fapp.component.html&amp;image=https%3A%2F%2Fsocial-img.staticblitz.com%2Fprojects%2Fstackblitz-starters-22fu8pz8%2Fc6d63aa7326966ca8850bd91b93b0485&amp;type=text%2Fhtml&amp;schema=stackblitz" allowfullscreen="" frameborder="0" height="400" width="745" title="stackblitz-starters-22fu8pz8 - StackBlitz" class="eo n fi dz bg" scrolling="no"></iframe>

# **Key Security Practices for Angular App Security**

1.  **XSS (Cross-site scripting) attack**
2.  **Preventing HTTP — level Vulnerabilities**
3.  **Secure Communication with APIs**
4.  **Enable Strict CSP & Offline Template Compiler**
5.  **Secure Development Best Practices**

# XSS (Cross-site scripting) attacks

Cross-site scripting (XSS) is a cyber-attack where hackers/attackers inject malicious scripts into web pages that other users visit. These scripts can then steal sensitive information like login credentials or cookies, or even take control of the user’s actions on the site. Attackers often exploit vulnerabilities in websites that allow them to insert harmful code, such as through input fields or URL parameters. XSS attacks can affect any user interacting with the compromised page, making it a significant threat to online security. To prevent XSS attacks, developers need to sanitize and validate all user inputs and carefully manage how data is displayed on web pages to ensure it cannot execute harmful scripts.

![](https://miro.medium.com/v2/resize:fit:875/1*pDRmlSgXmo-OalyGBx8Djw.png)

Use Angular’s DomSanitizer to convert untrusted values into trusted values. Use attribute binding for sanitization to prevent XSS attacks. Validate untrusted values depending on the security context (HTML, style, attributes, resources).

Angular categorizes data into different security contexts: HTML for content that should be treated as HTML (like inner HTML), Style for CSS styles, URL for links, and Resource URL security context for scripts that need to be loaded and run.

Angular identifies unsafe content in the input and automatically removes potentially harmful elements like \`<script>\` tags while retaining safe elements like \`<p>\` tags before displaying them on the webpage. This helps prevent security risks such as XSS attacks by sanitizing inputs before rendering them.

These methods in Angular mark a value as trusted for specific types:

1.  **bypassSecurityTrustScript**: Marks a value as trusted for use as a script.
2.  **bypassSecurityTrustStyle**: Marks a value as trusted for use in styles.
3.  **bypassSecurityTrustUrl**: Marks a value as trusted for use in URLs.
4.  **bypassSecurityTrustResourceUrl**: Marks a URL as trusted for loading resources.

They bypass Agular's default security checks to allow these values to be used safely in the specified contexts, helping to prevent security vulnerabilities when handling dynamic content.

To protect against XSS attacks on the server side in Angular applications, use a templating language that automatically escapes values. This prevents attackers from injecting malicious code into HTML generated on the server.

# Cross site request forgery (CSRF) attack

Cross site request forgery (CSRF), also known as XSRF, Sea Surf or Session Riding, is an attack vector that tricks a web browser into executing an unwanted action in an application to which a user is logged in.

A successful CSRF attack can be devastating for both the business and user. It can result in damaged client relationships, unauthorized fund transfers, changed passwords and data theft — including stolen session cookies.

![](https://miro.medium.com/v2/resize:fit:875/1*DuFVH1Lx8NMNbWCC84maLQ.png)

CSRFs are typically conducted using malicious social engineering, such as an email or link that tricks the victim into sending a forged request to a server. As the unsuspecting user is authenticated by their application at the time of the attack, it’s impossible to distinguish a legitimate request from a forged one.

![](https://miro.medium.com/v2/resize:fit:875/1*yn3-9ecigpcfMA0moO-pQw.png)

## CSRF example

Before executing an assault, a perpetrator typically studies an application in order to make a forged request appear as legitimate as possible.

For example, a typical GET request for a $100 bank transfer might look like:

GET http://netbank.com/transfer.do?acct=PersonB&amount=$100 HTTP/1.1

A hacker can modify this script so it results in a $100 transfer to their own account. Now the malicious request might look like:

GET http://netbank.com/transfer.do?acct=AttackerA&amount=$100 HTTP/1.1

A bad actor can embed the request into an innocent looking hyperlink:

<a href="http://netbank.com/transfer.do?acct=AttackerA&amount=$100"\>Read more!</a>

Next, he can distribute the hyperlink via email to a large number of bank customers. Those who click on the link while logged into their bank account will unintentionally initiate the $100 transfer.

Note that if the bank’s website is only using POST requests, it’s impossible to frame malicious requests using a <a> href tag. However, the attack could be delivered in a <form> tag with automatic execution of the embedded JavaScript.

This is how such a form may look like:

<body onload\="document.forms\[0\].submit()"\>  
   <form action\="http://netbank.com/transfer.do" method\="POST"\>  
     <input type\="hidden" name\="acct" value\="AttackerA"/>  
     <input type\="hidden" name\="amount" value\="$100"/>  
     <input type\="submit" value\="View my pictures!"/>  
   </form\>  
 </body\>

## Methods of CSRF mitigation

A number of effective methods exist for both prevention and mitigation of CSRF attacks. From a user’s perspective, prevention is a matter of safeguarding login credentials and denying unauthorized actors access to applications.

Best practices include:

-   Logging off web applications when not in use
-   Securing usernames and passwords
-   Not allowing browsers to remember passwords
-   Avoiding simultaneously browsing while logged into an application

For web applications, multiple solutions exist to block malicious traffic and prevent attacks. Among the most common mitigation methods is to generate unique random tokens for every session request or ID. These are subsequently checked and verified by the server. Session requests having either duplicate tokens or missing values are blocked. Alternatively, a request that doesn’t match its session ID token is prevented from reaching an application.

Double submission of cookies is another well-known method to block CSRF. Similar to using unique tokens, random tokens are assigned to both a cookie and a request parameter. The server then verifies that the tokens match before granting access to the application.

While effective, tokens can be exposed at a number of points, including in browser history, HTTP log files, network appliances logging the first line of an HTTP request and referrer headers, if the protected site links to an external URL. These potential weak spots make tokens a less than full-proof solution.

# Secure Communication with APIs

Communication with APIs is essential for protecting sensitive data exchanged between clients and servers. Using HTTPS encrypts data during transmission, safeguarding against eavesdropping and tampering. Implementing CORS (Cross-Origin Resource Sharing) ensures that only trusted domains can access resources, preventing unauthorized requests from malicious sites.

Encrypting sensitive client-side data before sending it to servers adds layer of security, making intercepted data unreadable.

Avoiding storing sensitive information on clients and opting for secure storage mechanisms like HTTP-only cookies for tokens and credentials further enhances protection against potential threats.

These practices collectively ensure that API communications are robustly secured, maintaining data integrity and user privacy.

![](https://miro.medium.com/v2/resize:fit:875/1*zctUB9yuafmGpQrJCa_Hhw.png)

# Avoid Security Risk Angular API

It’s crucial to avoid using Angular APIs labeled as “Security Risk” in the documentation, particularly ElementRef. ElementRef allows direct access to the DOM, which can expose your application to XSS (Cross-Site Scripting) attacks if not used carefully. Instead, rely on Angular’s templating and data binding capabilities whenever possible, as they provide safer alternatives.

When direct DOM access is unavoidable, consider using Renderer2, which offers a secure API to interact with native elements without compromising security. By following these guidelines, you can minimize risks associated with vulnerable APIs and strengthen the overall security of both your users and Angular applications.

![](https://miro.medium.com/v2/resize:fit:875/1*L92QwpR_hfG4CLGCt951NA.png)

# Never use native DOM APIs to interact with HTML elements

Avoid direct DOM manipulation and use Angular template mechanisms, and Agular's own APIs to manipulate the DOM instead. As a general guideline, avoid the following:

-   `node.appendChild();`
-   using the `document` object methods to interact with the page
-   using jQuery APIs

There are native Angular APIs that allow the same type of direct DOM manipulation that we’re advising against — for example, the **ElementRef API**. Angular ElementRef introduces security issues when used to gain access to a direct DOM node and perform manipulations at that point.

This and other interactions outside of the Angular set of APIs could potentially lead to security vulnerabilities.

# Avoid template engines on server-side templates

Angular security best practice #5: Avoid 3rd party template engines to create or add templates data on Angular server-side rendered applications.

If you’ve been using Node.js to build web applications, you have probably used a template engine such as EJS, Pug, **Handlebars**, or one of their alternatives at some point in time. They are used to manage server-side rendered templates for the view layer and may include partials or layouts composites, and other sorts of features that help dynamically generate a view.

However, implementing these template engine mechanisms in a configuration of Angular’s server-side rendered application could lead to potential injection of malicious code into a template. That happens because data injected is external to the scope of the Angular API and cannot be sanitized, posing the same risks as template string concatenation

# Scan your Angular project for components which introduce security vulnerabilities

When it comes to using third-party libraries, like Angular and its ecosystem of modules or components, you should keep the following in mind: security vulnerabilities affecting the core Angular library, and security vulnerabilities in the third-party Angular modules you are importing and using in your project.

**Using components with known vulnerabilities** is actually a documented **OWASP Top 10** web security risk that you should be aware of.In fact, the picture below shows a list of Angular modules with known security vulnerabilities, for example, those that would get flagged when you run an `npm install` or `npm audit`. Indeed, as you see in this picture taken from our **JavaScript Frameworks Security report**, some of these are winning millions of downloads a year yet have **no security fix** to this date:

![](https://miro.medium.com/v2/resize:fit:875/0*cMTfFdO5gF3M55dl)

# **Enable Strict CSP**

To enable Strict CSP(Content Security Policy) configure your web server to include a Content-Security-Policy HTTP header with directives for script and style sources, and enhanced security and performance.

To make an application compatible with strict CSP it is usually necessary to make some changes to HTML templates and client-side code, add the policy header, and test that everything works properly once the policy is deployed. This page walks you through the common steps.

## **Add nonces to <script> elements**

With strict CSP, every `<script>` element must have a `nonce` attribute containing a random, unguessable token which matches the value specified in the policy. The first step is to add these attributes to all scripts:

<script src\="/path/to/script.js"\></script\>  
<script\>foo()</script\>

becomes (depending on the template system syntax):

<script nonce\="${nonce}" src\="/path/to/script.js"\></script\>  
<script nonce\="${nonce}"\>foo()</script\>

If you use Closure Templates , the template system will [add nonce attributes automatically](https://developers.google.com/closure/templates/docs/security#content_security_policy) without requiring any changes to your templates if you pass the nonce value as [injected data](https://developers.google.com/closure/templates/docs/concepts#injecteddata).

In other template systems you will need to modify the templates which include `<script>` tags to add the `nonce` attribute and set its value.

default\-src 'self';   
script\-src 'self';   
style\-src 'self';                   
img\-src 'self' data:;   
font\-src 'self';   
connect\-src 'self';

**Here’s how the policy works:**

-   **Default-src**Script-src **‘self’:** All content has to be fetched from the same domain as that which hosted the HTML page.
-   **Script-src ‘self’ https:** An API service (_https://apis.example.com_) serves as the only source for JavaScript loaded on the website.
-   **img-src ‘self’ data:** One can retrieve images from their origin or represent them as data URIs.

We can set the CSP directives in the meta tag as well. To set the directives in an angular application. The CSP meta tag allows you to define a Content Security Policy in HTML <head> Section. Configuring CSP with meta tags is a good way to implement and test Content Security Policies directly within your HTML documents.

<! --- index.html --->  
<!DOCTYPE html\>  
<html lang\="en"\>  
<head\>  
    <meta charset\="utf-8" />  
    <title\>AngularCsp</title\>  
    <base href\="/" />  
    <meta name\="viewport"  
          content\="width=device-width,  
                   initial-scale=1" />  
    <link rel\="icon" type\="image/x-icon"  
          href\="favicon.ico" />  
    <meta http-equiv\="Content-Security-Policy"  
        content\="default-src 'self'; script-src 'self'; style-src 'self';  
                 img-src 'self' data:; font-src 'self'; connect-src 'self';" />  
</head\>  
<body\>  
    <app-root\></app-root\>  
</body\>  
</html\>

[

## Content Security Policy (CSP) - GeeksforGeeks

### A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and…

www.geeksforgeeks.org



](https://www.geeksforgeeks.org/content-security-policy-csp/?ref=asr1&source=post_page-----02da7669f476---------------------------------------)

## How to Use a Nonce in Angular

If your Angular application has a CSP and you do not want to use `‘unsafe-inline’` (and you shouldn’t if you can help it), this is the _minimum_ policy you must have according to Angular (line breaks added for readability):

default\-src 'self';   
style-src 'self' 'nonce-randomNonceGoesHere';   
script-src 'self' 'nonce-randomNonceGoesHere';

Since Angular 16, You can set the nonce for Angular in one of two ways:

1.  Set the `ngCspNonce` attribute on the root application element as `<app ngCspNonce="randomNonceGoesHere"></app>`. Use this approach if you have access to server-side templating that can add the nonce both to the header and the `index.html` when constructing the response.
2.  Provide the nonce using the `CSP_NONCE` injection token. Use this approach if you have access to the nonce at runtime and you want to be able to cache the `index.html`.

import {bootstrapApplication, CSP\_NONCE} from '@angular/core';  
import {AppComponent} from './app/app.component';  
bootstrapApplication(AppComponent,   
  {  providers:   
    \[{      
      provide: CSP\_NONCE,  
      useValue: globalThis.myRandomNonceValue    
    }\]  
}  
);

# Offline Template Compiler

The offline template compiler in Angular compiles templates during the build process, rather than at runtime, which improves security and performance.

`tsconfig.json`: Set `angularCompilerOptions.fullTemplateTypeCheck` to `true` in your `tsconfig.json` file.

{  
      "angularCompilerOptions": {  
            "fullTemplateTypeCheck": true  
      }  
}

**Benefits:**

-   **Enhanced Security:** Prevents template injection vulnerabilities.
-   **Improved Performance:** Templates are compiled ahead of time, reducing runtime overhead.

# Secure Development Best Practices

Following are the secure coding practices:

1\. **Secure Authentication**:

Use strong hashing algorithms (like bcrypt) to securely store passwords. This ensures passwords are not easily compromised even if your database is breached

Enforce password policies such as minimum length, complexity requirements (including numbers and special characters), and periodic password changes.

![](https://miro.medium.com/v2/resize:fit:730/0*uTe-n4QZUGgj7xmn.png)

2\. **Avoid Hazardous Angular API Endpoints**:

Avoid using Angular API endpoints that are overloaded, unavailable, or incorrect, as they can cause application failures or unpredictable behavior.

Ensure that API endpoints are well-documented, maintained, and adhere to RESTful principles for consistency and reliability in communication between Angular frontend and backend services.

3\. **Stay Updated**:

Regularly update your Angular libraries to the latest versions. Updates often include security fixes that protect against known vulnerabilities. Check the Angular change log for security-related updates and best practices.

4\. **Security Audits**:

Conduct Angular application security audits to identify and address potential vulnerabilities. This ensures that you follow security best practices and maintain robust protection against threats.

5\. **Use Route Guards**:

Implement route guards to control access to specific routes based on user authentication and authorization. This helps ensure that only authorized users can access sensitive or restricted areas of your application.

6\. **Keep Dependencies Updated**:

Use npm (Node Package Manager) to keep Angular and its dependencies up to date. Regular updates help to mitigate risks associated with known vulnerabilities in third-party libraries and packages.

# Do I even need a BEARER token, if i have a CSRF token?

The bearer token is your login token to an external api-service like a passport or member-card, so you are granted access to this external service. The token also tells the server who the person/machine accessing the resource is, so the server can decide if they have the correct permissions.

The CSRF token protects you from request forgery, meaning someone making a request to your server from an external server or tool. The only thing a CSRF token tells you is that the request came from someone using your site, it doesn’t tell you who that person is or what permissions they have.

## Embedded Content
# Angular Components Communication — Like a Pro | by Ionut Anghel | Level Up Coding

# Angular Components Communication — Like a Pro

## Simplifying Interaction in Your App

[

![Ionut Anghel](https://miro.medium.com/v2/resize:fill:64:64/1*Rie1ppKcKx8SyrhbfPdUGg.jpeg)





](https://medium.com/@ionut-anghel?source=post_page---byline--06c3141099b3---------------------------------------)

[Ionut Anghel](https://medium.com/@ionut-anghel?source=post_page---byline--06c3141099b3---------------------------------------)

Follow

3 min read

·

Jan 8, 2024

72

Listen

Share

More

In the realm of Angular development, efficient communication between components is a key factor in building robust applications.

This article aims to simplify the understanding of how Angular components communicate, exploring various techniques, when to use them, and their significance in creating well-structured and interactive Angular applications.

![](https://miro.medium.com/v2/resize:fit:875/0*IwhAaDaVzzNVMNqs)
Glenn Carstens-Peters — Unsplash

# Understanding Angular Components Communication

Angular components are the building blocks of an application, and they often need to share data or trigger actions with one another. Understanding how components communicate is crucial for creating a cohesive and responsive user interface.

# Why Is Components Communication Important?

Effective communication between Angular components is essential for several reasons:

1.  **Modularity**: Components encapsulate specific functionality, and communication allows them to work together cohesively while maintaining modularity.
2.  **Reusability**: Components can be reused in different parts of the application, and communication enables them to adapt and interact seamlessly.
3.  **Parent-Child Relationships**: In hierarchical component structures, parent and child components need to exchange data or trigger events.
4.  **Maintainability**: Well-established communication patterns contribute to code maintainability, making it easier to understand and update.

# When to Use Each Communication Strategy

Choosing the right communication strategy depends on the specific use case:

1.  **@Input and @Output**: Ideal for parent-child relationships, where the parent needs to pass data to the child, and the child needs to emit events to the parent.

// Child Component  
import { Component, Input, Output, EventEmitter } from '@angular/core';  
  
@Component({  
  selector: 'app-child',  
  template: \`<div (click)="emitEvent()">Child Component</div>\`,  
})  
export class ChildComponent {  
  @Input() dataFromParent: string = '';  
  @Output() customEvent = new EventEmitter<string\>();  
  
  emitEvent() {  
    this.customEvent.emit('Event from Child');  
  }  
}

// Parent Component  
import { Component } from '@angular/core';  
  
@Component({  
  selector: 'app-parent',  
  template: \`  
    <app-child \[dataFromParent\]="parentData" (customEvent)="handleEvent($event)"></app-child>  
  \`,  
})  
export class ParentComponent {  
  parentData: string = 'Data from Parent';  
  
  handleEvent(eventData: string) {  
    console.log('Event received in Parent:', eventData);  
  }  
}

2\. **Services for Shared Data**: Angular services can act as a centralized hub for sharing data between components. Components inject the same service to access shared data.

// Shared Service  
import { Injectable } from '@angular/core';  
import { BehaviorSubject } from 'rxjs';  
  
@Injectable({  
  providedIn: 'root',  
})  
export class DataService {  
  private sharedDataSubject = new BehaviorSubject<string\>('Initial Data');  
  sharedData$ = this.sharedDataSubject.asObservable();  
  
  updateSharedData(newData: string) {  
    this.sharedDataSubject.next(newData);  
  }  
}

// Components using the Shared Service  
import { Component, OnInit } from '@angular/core';  
import { DataService } from './data.service';  
  
@Component({  
  selector: 'app-component-a',  
  template: \`<div>{{ sharedData }}</div>\`,  
})  
export class ComponentAComponent implements OnInit {  
  sharedData: string = '';  
  
  constructor(private dataService: DataService) {}  
  
  ngOnInit() {  
    this.dataService.sharedData$.subscribe((data) => {  
      this.sharedData = data;  
    });  
  }  
}

3\. **ViewChild and ContentChild**: Useful when a parent component needs to directly interact with its child components.

// Parent Component with ViewChild  
import { Component, ViewChild, AfterViewInit } from '@angular/core';  
import { ChildComponent } from './child.component';  
  
@Component({  
  selector: 'app-parent',  
  template: \`  
    <app-child></app-child>  
    <button (click)="callChildMethod()">Call Child Method</button>  
  \`,  
})  
export class ParentComponent implements AfterViewInit {  
  @ViewChild(ChildComponent) childComponent!: ChildComponent;  
  
  ngAfterViewInit() {  
    this.childComponent.childMethod();  
  }  
  
  callChildMethod() {  
    this.childComponent.childMethod();  
  }  
}

4\. **Event Emitters**: Appropriate for scenarios where components need to communicate custom events, especially when the components are not closely related.

// Event Emitter Service  
import { Injectable, EventEmitter } from '@angular/core';  
  
@Injectable({  
  providedIn: 'root',  
})  
export class EventService {  
  customEvent = new EventEmitter<string\>();  
}

// Components using the Event Emitter Service  
import { Component } from '@angular/core';  
import { EventService } from './event.service';  
  
@Component({  
  selector: 'app-component-b',  
  template: \`  
    <button (click)="emitEvent()">Emit Event</button>  
  \`,  
})  
export class ComponentBComponent {  
  constructor(private eventService: EventService) {}  
  
  emitEvent() {  
    this.eventService.customEvent.emit('Custom Event Data');  
  }  
}

# Conclusion

In the dynamic world of Angular development, mastering various communication strategies between components is crucial for building interactive and maintainable applications. These practical examples showcase the application of different techniques in real-world scenarios, providing a foundation for creating robust Angular applications.

By understanding when to use @Input and @Output, services, ViewChild and ContentChild, and event emitters, developers can navigate the intricacies of Angular components communication, fostering modular, reusable, and well-communicating components.

## Embedded Content
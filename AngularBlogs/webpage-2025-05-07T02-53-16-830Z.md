# How I Made My Java Code 15x Faster: A Deep Dive into Profiling and Optimization | by Yashbatra | Apr, 2025 | Medium

Member-only story

# How I Made My Java Code 15x Faster: A Deep Dive into Profiling and Optimization

[

![Yashbatra](https://miro.medium.com/v2/resize:fill:64:64/1*qzg4k1dbmci1Z47Qm6BTsQ@2x.jpeg)





](/@yashbatra11111?source=post_page---byline--c40856f16b92---------------------------------------)

[Yashbatra](/@yashbatra11111?source=post_page---byline--c40856f16b92---------------------------------------)

Follow

3 min read

Â·

Apr 12, 2025

30

1

Listen

Share

More

Performance optimization in Java isnâ€™t just about tweaking a few lines â€” itâ€™s a process of understanding bottlenecks, profiling behavior, and applying targeted improvements. In one of my recent projects, I managed to improve performance by 15x. Hereâ€™s exactly how I did it.

![](https://miro.medium.com/v2/resize:fit:800/1*P-IBOFSlvapIim1yCNXd0w.gif)

# The Problem: Slow Batch Processing in a Critical Workflow

We had a Java microservice responsible for processing incoming financial transactions. As traffic increased, the service started to lag significantly. What once took under a second per batch ballooned to 15 seconds. With business stakeholders breathing down our necks, optimization became top priority.

# Step 1: Profiling with JFR and JVisualVM

I began by profiling the application under load using Java Flight Recorder (JFR) and JVisualVM.

# Findings:

-   Excessive object creation and garbage collection.
-   Unnecessary string concatenations in loops.
-   Heavy reflection-based deserialization.

These were the red flags I knew I needed to tackle.

# Step 2: Reducing Object Allocations

Previously, we were creating new DTO objects for every transaction inside a loop. This caused a spike in memory allocations and GC activity.

# Before:

List<TransactionDTO> dtos = new ArrayList<>();  
for (Transaction tx : transactions) {  
    dtos.add(new TransactionDTO(tx));  
}

# After:

We reused DTO instances by maintaining a pool.

ObjectPool<TransactionDTO> dtoPool = new ObjectPool<>(TransactionDTO::new);  
for (Transaction tx : transactions) {  
    TransactionDTO dto \= dtoPool.borrow();  
    dto.populateFrom(tx);  
    dtos.add(dto);  
}

âœ… **Result:** 30% reduction in memory usage.

# Step 3: Optimizing String Handling

We had string concatenations inside tight loops. This was a silent killer.

# Before:

String report \= "";  
for (Transaction tx : transactions) {  
    report += tx.toSummary();  
}

# After:

StringBuilder reportBuilder \= new StringBuilder();  
for (Transaction tx : transactions) {  
    reportBuilder.append(tx.toSummary());  
}  
String report \= reportBuilder.toString();

âœ… **Result:** Reduced CPU usage by 20% during peak processing.

# Step 4: Avoiding Reflection in Serialization

We were using a reflection-heavy JSON library. Switching to a faster, annotation-based alternative like Jackson with precompiled schemas made a big difference.

âœ… **Result:** Serialization/deserialization time dropped by 50%.

# Step 5: Parallelism and Concurrency

The processing was done sequentially, but our system had more than enough CPU to parallelize work.

# Before:

for (Transaction tx : transactions) {  
    process(tx);  
}

# After:

transactions.parallelStream().forEach(this::process);

âœ… **Result:** Throughput increased 3x.

Note: We made sure the `process()` method was thread-safe before doing this.

# Step 6: Connection Pool Tuning

Our service made multiple DB calls but used the default HikariCP config.

# Optimization:

-   Increased pool size from 10 to 50.
-   Tuned connection timeout and idle time.

âœ… **Result:** DB wait time dropped significantly, improving end-to-end latency.

# Final Outcome

After applying these optimizations:

-   **Batch processing time dropped from 15s to under 1s.**
-   **Memory footprint reduced by 40%.**
-   **CPU usage stabilized under high load.**

What started as a sluggish service became one of our most efficient pipelines.

# Key Takeaways

1.  **Profile before optimizing** â€” Always measure before making changes.
2.  **Avoid unnecessary object creation** â€” Especially inside loops.
3.  **Use efficient data handling techniques** â€” Like `StringBuilder` for string manipulation.
4.  **Be cautious with reflection** â€” Itâ€™s powerful but often slow.
5.  **Leverage parallelism wisely** â€” Only when your code is thread-safe.
6.  **Tune infrastructure settings** â€” Like DB connection pools.

# One Final Thought:

Optimization isnâ€™t about guesswork. Itâ€™s about understanding what your system is doing â€” and then doing it better.

Let me know if youâ€™ve gone through a similar transformation or need help speeding up your own Java services. ðŸš€

## Embedded Content

---
# NGRX in Angular (Interview). What is NgRx? | by Piyali Das | Medium

# NGRX in Angular (Interview)

[

![Piyali Das](https://miro.medium.com/v2/resize:fill:64:64/1*Lw8C8pu0QC2ZxW0oJ8jAqA.jpeg)





](/@piyalidas.it?source=post_page---byline--44c503d7648d---------------------------------------)

[Piyali Das](/@piyalidas.it?source=post_page---byline--44c503d7648d---------------------------------------)

Follow

6 min read

·

Feb 24, 2025

3

Listen

Share

More

# What is NgRx?

## Flux design pattern

During the last decade, Facebook has popularized an approach in building single page Web Applications called the [Flux](https://facebook.github.io/flux/docs/in-depth-overview/). [Redux](https://redux.js.org/), a vastly popular state management library for React, is built using the Flux approach, and so is NgRx. They have similar (almost the same) concepts, and serve the same need. **NgRx can be called “Redux + RxJS”**. It combines the simplicity and centralization of Redux with the power of `Observables`.

## So what does Flux do?

Flux solves this problem with a series of easy to grasp concepts, which bundled together comprise a state management system. It sort of utilizes both previous approaches in a way that

-   Makes state easy to synchronize
-   Makes changes to the state easy to track
-   Allows to a actually debug state changes
-   Is declarative

NgRx does the same, but for Angular. If at this point you think “why do I event bother? My app works fine right now”, then let’s now explore why exactly do we need solutions like NgRx.

# Why do we need NgRx?

NgRx, as mentioned, is built on concepts of Redux. It utilizes core ideas like `Stores` (the place where the application states are stored), `Actions` (events that notify the `Store` that some change to the state is to happen), `Reducers` (functions that determine how a certain `Action` affects the `State`), and also adds concepts like `Selectors` (functions that allow to pick a slice of the `State` as an `Observable`) and `Effects` (special functions that work on side effects like data loading and API calls). It also provides utility functions to make writing boilerplate code easier and even utility libraries like `@ngrx/entity` to work with large lists of data.

# NGRX Actions, Reducers

## What are Actions?

`Actions` are the most simple core concept of NgRx (and Redux in general). Action is a unique event that is used to trigger a change in the state. What does it mean? For example, we might have an action that says "Home page has been loaded". It might mean some changes in the state. For example, in our application, it might trigger an API call for lists of expenses and incomes, which will in turn trigger an event that puts that data in the `Store`, resulting in a change in the UI. Or we might have an action that says "Add a category", which will create a new category of income/expense in the `Store`, again resulting in a UI change. Again, essentially `Actions` are like commands to the `Store`, or methods that allow to update its contents.

state/actions.ts  
import { createAction, props } from "@ngrx/store";  
import { Category } from "./state";  
  
export const addCategory = createAction(  
  "\[Category List\] Add Category",  
  props<{ category: Category }>()  
);  
  
app.component.ts  
\--------------------------------------------------------  
import { Component, OnInit } from "@angular/core";  
import { addCategory } from "./state/actions";  
  
@Component({/\* ... \*/})  
export class AppComponent implements OnInit {  
  ngOnInit() {  
    console.log(addCategory({category:{ name: "Food" }}));  
  }  
}

## What are Reducers?

Reducers are _pure functions_ that receive two arguments, the current `State` of the application, an `Action` object, calculate the new state based on the `Action` that happened, and return that new `State`. Usually calculating involves determining which `Action` happened (sometimes via `switch-case` statements, but NgRx provides utilities that reduce boilerplate), copying the previous state into a new object while modifying the relevant properties of the `State`, and returning the new `State` object. Every time an `Action` is dispatched (we will learn more about dispatching in the next chapters, for now "dispatching" an `Action` means the `Action` has happened), NgRx will call the `Reducer` function, providing the old `State` and the `Action` object as arguments, get the returned new `State` and immediately notify all of our components about the change (how neat is that!). Essentially, `Reducers` are the central place where `State` changes happen.

import { Action } from "@ngrx/store";  
  
import { AppState } from "./state";  
  
export function reducer(state: AppState, action: Action) {  
  switch (action.type) {  
    case "\[Category List\] Add Category":  
      return { ...state, categories: \[...state.categories, action.payload\] };  
    default:  
      return state;  
  }  
}

## What are Selectors?

In most simple terms, `Selectors` are `pure functions` that take the `State` of ur application, and return a piece of it so that it can be used in a component (you will see NgRx extensively uses `pure functions`). In more detail, in the future chapters, our `State` will evolve to contain lots of data in the main object, for example, we will have categories, expenses, incomes, probably data about the current user (authentication, full name, etc) and so on. Obviously in a single component we don't need the entire `State`, thus we write `Selectors` which will return pieces of that `State`, for example, a `Selector` that return only the array of categories to use in the corresponding component.

Those pieces are called “slices” of the `State` sometimes, but often the term `derived State` is used, to indicate it is some modified form of the original `State`. `Selectors` can also be used to return not just a slice, but some complex calculation of the `State`, for example, we can write a `Selector` that calculates the total income based on all the items in the `incomes` array, and based on that `Selector`, another one that calculates the average.

This chapter is called “Basic Selectors”, so in this one we are going to write only such `Selectors` that return just slices of the `State`; in the future chapters, we will write more complex `Selectors` and learn how to create new `Selectors` from existing ones, and also how to combine them into new ones.

src/app/state/selectors.ts  
import { AppState } from "./state";  
  
export const categories = (state: { categories: AppState }) =>  
  state.categories.categories;  
  
  
category-list-container.component.ts  
\------------------------------------------------------------------------  
import { Component } from "@angular/core";  
import { Store } from "@ngrx/store";  
  
import { categories } from "../../state/selectors";  
  
@Component({  
  selector: "app-category-list-presenter",  
  template: \`  
    <app-category-list-presenter \[categories\]="categories$ | async">  
    </app-category-list-presenter>  
  \`,  
})  
export class CategoryListContainer {  
  categories$ = this.store.select(categories);  
  
  constructor(private readonly store: Store) {}  
}

# NPM Packages

dependencies  
\===================================================================  
"@ngrx/effects": "^15.4.0",  
"@ngrx/entity": "^15.4.0",  
"@ngrx/store": "^15.4.0",  
"ngrx/store-devtools": "\*",

# StoreModule.forRoot() vs StoreModule.forFeature() with EffectModule

**forRoot :::** The **forRoot** method is invoked in the AppModule and, generally, **once in the application** to initialize the Store and provide the initial reducers/actions/state configuration. If you use the EffectsModule, you’ll invoke the forRoot method on this module too:

@ngModule({   
  imports: \[   
    StoreModule.forRoot({}),   
    EffectsModule.forRoot(\[\])   
  \]   
})  
  
class AppModule {}

**forFeature :::** The **forFeature** method is invoked in any feature module that requires it’s own part of the state management: as an example, an UserModule will define it’s own portion of the state, describing the required actions, reducers and so on. If you use the EffectsModule, remember to invoke the forFeature method against it too. As you may have understood by yourself, _forFeature_ (as the more generic Angular’s _forChild_ method) can be invoked multiple times for the same imported module in the application:

AppModule  
\------------------------------------------------------------------  
@ngModule({   
  imports: \[   
    StoreModule.forRoot({}),   
    EffectsModule.forRoot(\[\])   
  \]   
})  
  
UsersModule  
\------------------------------------------------------------------  
@ngModule({   
  imports: \[   
    StoreModule.forFeature('usersFeature', UserReducers),  
    StoreModule.forFeature('logsFeature', LogsReducer),   
    EffectsModule.forFeature(\[UserEffects, LoginEffects, LogsEffects\])  
  \]   
})

As you have noticed, instead of `forRoot` we used methods called `forFeature`, which indicate these are reducers and effects that are being added dynamically, after the user visits this particular module. The `StoreModule.forFeature` method's first argument is the name of the feature state, which is being used when writing feature specific selectors.

# EffectsModule

EffectsModule. forRoot is required to wire up application level providers and must be registered only once before EffectsModule. forFeature is used. You can provide forRoot with an empty array if you don’t need to register any effects in the root.

`EffectsModule.forFeature()` is basically the same function as `EffectsModule.forRoot()` except the fact that the providers aren't loaded.

# forRoot vs forFeature

below every number represents a module

        0                                                                                                  
    1       2                                                                                              
  3   4   5   6

if I do `forRoot(databaseConfig)` on module `1` then `1, 3, 4` can use databaseConfig  
if I do `forFeature(databaseConfig)` on module `1` then only `1` can use the databaseConfig  
if I do `forRoot(databaseConfig)` on module `0` then all can use the databaseConfig

## Embedded Content
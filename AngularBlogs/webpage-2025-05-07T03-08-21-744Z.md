# SpringBoot @Async: The magic and the gotchas | by Divya Vikash | Medium

# SpringBoot @Async: The magic and the gotchas

[

![Divya Vikash](https://miro.medium.com/v2/resize:fill:64:64/1*nLL25aZ2AWmntO1zO3B6Nw@2x.jpeg)





](/@dvikash1001?source=post_page---byline--17f9471c6fe4---------------------------------------)

[Divya Vikash](/@dvikash1001?source=post_page---byline--17f9471c6fe4---------------------------------------)

Follow

7 min read

·

Jan 29, 2023

470

9

Listen

Share

More

![](https://miro.medium.com/v2/resize:fit:875/0*agUuFqoSeXLwVcar)
Photo by Markus Spiske on Unsplash

The **@Async** annotation is like the secret weapon of performance optimization in a springboot project. Yeah, we can manually create our own executors and threadpools as well but **@Async** makes things much simpler and more magical.

The **@Async** annotation lets us run code in the background, so our main thread can keep chugging along without waiting for slower tasks to finish. But, like all secret weapons, it’s important to use it wisely and know its limits. In this post, we’re gonna dive deep into the **@Async** magic and the gotchas we should watch out for when we are using it in our Spring Boot projects. Let’s get started!

First let’s learn the basics of how to use @Async in our application.

First of all, we need to enable **@Async** in our Spring Boot application. To do this, we will need to add the **@EnableAsync** annotation to a configuration class or to our main application file. This will enable asynchronous behavior for all methods annotated with **@Async** in the application.

@SpringBootApplication  
@EnableAsync  
public class BackendAsjApplication {  
}

We will also need to create a Bean specifying the configurations for methods annotated with @Async. We can set things like max threadpool size, queue size etc. Be careful while adding these configurations though. Otherwise, we might run out of memory very soon. I usually also add a log to warn me when the queue size is full and there are no more threads to pick up the new incoming task.

 @Bean  
 public ThreadPoolTaskExecutor taskExecutor() {  
  ThreadPoolTaskExecutor executor \= new ThreadPoolTaskExecutor();  
  executor.setCorePoolSize(2);  
  executor.setMaxPoolSize(2);  
  executor.setQueueCapacity(500);  
  executor.setThreadNamePrefix("MyAsyncThread-");  
  executor.setRejectedExecutionHandler((r, executor1) -> log.warn("Task rejected, thread pool is full and queue is also full"));  
  executor.initialize();  
  return executor;  
 }

Now, let’s use it. Suppose we have a service class that contains a method that we want to make asynchronous. We will annotate this method with **@Async**.

@Service  
public class EmailService {  
    @Async  
    public void sendEmail() {  
     
    }  
}

_(In the code examples, you will see EmailService and PurchaseService mentioned many times. These are just examples. I don’t wanna name everything as “MyService”. So, naming it to something which is more meaningful. In an e-commerce application, you would of course want your EmailService to be async so that customer requests are not blocked on that)_

Now, when we call this method, it will return immediately, freeing up the calling thread (usually the main thread) to continue with other tasks. The method will continue to execute in the background and the result will be returned to the calling thread at a later time. Since we have marked our @Async method here with void, we are not really interested in when it completes.

Pretty easy and pretty powerful, right? (Of course there are a lot more configurations that we can do but the above code is enough to run a task fully async)

But, before we start annotating all of our methods with @Async, there are a few gotchas that we need to be aware of.

## **@Async method needs to be in a different class**

When using the @Async annotation, it is important to note that we cannot call an @Async method from within the same class. This is because doing so will lead to an infinite loop and cause the application to hang.

Here’s an example of what NOT to do:

@Service  
public class PurchaseService {  
  
    public void purchase(){  
        sendEmail();  
    }  
  
    @Async  
    public void sendEmail(){  
        // Asynchronous code  
    }  
}

Instead, we should use separate classes or services for our asynchronous methods.

@Service  
public class EmailService {  
  
   @Async  
    public void sendEmail(){  
        // Asynchronous code  
    }  
}  
  
@Service  
public class PurchaseService {  
  
    public void purchase(){  
        emailService.sendEmail();  
    }  
  
    @Autowired  
    private EmailService emailService;  
}

Now you might be wondering, can I call an async method from within another async method? The short answer is no. When an async method is called, it’s executed in a different thread and the calling thread moves on to the next task. If the calling thread itself is an async method, it has no way of waiting for the called async method to finish before moving on, which can lead to unexpected behavior.

## @Async and @Transcational don’t play well

The @Transactional annotation is used to indicate that a method or a class should participate in a transaction. It is used to ensure that a group of database operations are performed as a single unit of work and that the database is left in a consistent state in case of any failures.

When a method is annotated with @Transactional, Spring creates a proxy around the method, and all the database operations within the method are executed within the context of a transaction. Spring also takes care of starting the transaction before the method is invoked and committing the transaction after the method returns, or rolling back the transaction in case of an exception.

However, when you use the @Async annotation to make a method asynchronous, the method is executed in a separate thread from the main application thread. This means that the method is no longer executed within the context of the transaction that was started by Spring. Because of this, the database operations within the @Async method will not participate in the transaction, and the database may be left in an inconsistent state in case of an exception.

@Service  
public class EmailService {  
  
    @Transactional  
    public void transactionalMethod() {  
        //database operation 1  
        asyncMethod();  
        //database operation 2  
    }  
  
    @Async  
    public void asyncMethod() {  
        //database operation 3  
    }  
}

In this example, database operation 1 and database operation 2 are executed within the context of the transaction started by Spring. But, database operation 3 is executed in a separate thread, and is not part of the transaction.

So, if an exception occurs before database operation 3 is executed, database operation 1 and database operation 2 will be rolled back as expected, but database operation 3 will not be rolled back. This can leave the database in an inconsistent state.

Of course, there are ways around this i.e using something like a TransactionTemplate to manage the transaction as well but the out-of-the-box, you will not get this support and will end up with issues if call an async method from a transcational method.

## @Async blocking Issues

![](https://miro.medium.com/v2/resize:fit:875/1*GyhdCmgbmaDvPI1jOlzeWQ.png)

Let’s suppose this is the configuration of our @Async threadpools:

@Bean  
 public ThreadPoolTaskExecutor taskExecutor() {  
  ThreadPoolTaskExecutor executor \= new ThreadPoolTaskExecutor();  
  executor.setCorePoolSize(2);  
  executor.setMaxPoolSize(2);  
  executor.setQueueCapacity(500);  
  executor.setThreadNamePrefix("MyAsyncThread-");  
  executor.setRejectedExecutionHandler((r, executor1) -> log.warn("Task rejected, thread pool is full and queue is also full"));  
  executor.initialize();  
  return executor;  
 }

This means that at any particular moment in time, we will have maximum 2 @Async tasks running. If more tasks come in, they will be queued up until the queue size reaches 500.

But now suppose, one of our @Async tasks is taking too much time to execute or it is simply blocked because of an external dependency. This will mean that all other tasks would be queued and will not be executed fast enough. This might cause delays depending on the type of your application.

One way to get around this problem is to have a separate threadpool for long running tasks and a separate threadpool for tasks which are more urgent and don’t take a lot of processing time. We can do that like this:

@Primary  
 @Bean(name = "taskExecutorDefault")  
 public ThreadPoolTaskExecutor taskExecutorDefault() {  
  ThreadPoolTaskExecutor executor \= new ThreadPoolTaskExecutor();  
  executor.setCorePoolSize(2);  
  executor.setMaxPoolSize(2);  
  executor.setQueueCapacity(500);  
  executor.setThreadNamePrefix("Async-1-");  
  executor.initialize();  
  return executor;  
 }  
  
 @Bean(name = "taskExecutorForHeavyTasks")  
 public ThreadPoolTaskExecutor taskExecutorRegistration() {  
  ThreadPoolTaskExecutor executor \= new ThreadPoolTaskExecutor();  
  executor.setCorePoolSize(2);  
  executor.setMaxPoolSize(2);  
  executor.setQueueCapacity(500);  
  executor.setThreadNamePrefix("Async2-");  
  executor.initialize();  
  return executor;  
 }

And then to use it, simply add the name of the executor in the @Async declaration:

@Service  
public class EmailService {  
    @Async("taskExecutorForHeavyTasks")  
    public void sendEmailHeavy() {  
        //method implementation  
    }  
}

However, note that we should not use @Async on methods that call `Thread.sleep()` or `Object.wait()` as it will block the thread and the purpose of using @Async will be defeated.

## Exceptions in @Async

![](https://miro.medium.com/v2/resize:fit:875/1*yzjG-V89I_H6oelZ0xMO_Q.png)
Source: stackify.com

Another thing to keep in mind is that @Async methods do not throw exceptions to the calling thread. This means that you need to handle exceptions properly within the @Async method, or else they will be lost.

Here’s an example of what NOT to do:

@Service  
public class EmailService {  
  
    @Async  
    public void sendEmail() throws Exception{  
        throw new Exception("Oops, cannot send email!");  
    }  
}  
  
@Service  
public class PurchaseService {  
      
    @Autowired  
    private EmailService emailService;  
  
    public void purchase(){  
        try{  
            emailService.sendEmail();  
        }catch (Exception e){  
            System.out.println("Caught exception: " + e.getMessage());  
        }  
    }  
}

In the above code, the exception is thrown in asyncMethod() but it will not be caught by the calling thread and the catch block will not be executed.

To properly handle exceptions in an @Async method, we can use a combination of Future and try-catch blocks. Here’s an example:

@Service  
public class EmailService {  
  
    @Async  
    public Future<String\> sendEmail() throws Exception{  
        throw new Exception("Oops, cannot send email!");  
    }  
}  
  
@Service  
public class PurchaseService {  
  
    @Autowired  
    private EmailService emailService;  
  
    public void purchase(){  
        try{  
            Future<String\> future = emailService.sendEmail();  
            String result = future.get();  
            System.out.println("Result: " + result);  
        }catch (Exception e){  
            System.out.println("Caught exception: " + e.getMessage());  
        }  
    }  
}

By returning a Future object and using a try-catch block, we can properly handle and catch exceptions thrown within an @Async method.

In conclusion, the @Async annotation in Spring Boot is a powerful tool for improving the performance and scalability of your application. But, it’s important to use it with care and be aware of its limitations. By understanding these gotchas and using techniques like `CompletableFuture` and an `Executor`, you can make the most of the @Async annotation and take your application to the next level.

## Embedded Content
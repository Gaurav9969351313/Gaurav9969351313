# 53 JavaScript Frontend Interview Questions | by Adarsh Rai | Medium

![](https://miro.medium.com/v2/resize:fit:5340/1*xovKaUlsE9xIA_k7p2GKpA.jpeg)
Photo by Sergey Zolkin on Unsplash

# 53 JavaScript Frontend Interview Questions

[

![Adarsh Rai](https://miro.medium.com/v2/resize:fill:64:64/1*dnQgwmU9XftzGoESypCvxA.jpeg)





](/@adarshrai3011?source=post_page---byline--e6013116eaa0---------------------------------------)

[Adarsh Rai](/@adarshrai3011?source=post_page---byline--e6013116eaa0---------------------------------------)

Follow

19 min read

·

Jan 13, 2024

722

10

Listen

Share

More

# Introduction

Many beginner and experienced developers are facing a problem with job searches due to the high level of competition in the market. Therefore, the best approach is to keep learning and improving your skills.

To help you prepare for interviews, I have compiled a list of 53 questions in a “question:answer” format for frontend developers. Although the questions are mainly geared towards Junior level developers, they also include questions for Middle level developers.

By preparing for these questions and thoroughly studying the topics, I was able to secure a job as a Middle Frontend Developer.

# 1\. What data types exist in JavaScript?

1.  Number — Numbers
2.  String — Strings
3.  Boolean — Boolean type, true or false
4.  Object — JavaScript object
5.  null — a special value that represents “nothing”, “empty”, or “unknown value”.
6.  undefined — “value has not been assigned”. This type is assigned if a variable is declared but has no assigned value.
7.  Symbol — a unique and immutable data type that can be used as an identifier for object properties.
8.  BigInt — used for creating large numbers.

`const bigInt = 1234567890123456789012345678901234567890n;`

[Learn more](https://javascript.info/types)

# 2\. What is the difference between “==” and “===”?

The operator “==” checks for abstract equality, while “===” checks for strict equality.  
In other words, the “==” operator performs necessary type conversions before comparison, whereas “===” does not perform type conversion. Therefore, if two values are not of the same type, it will return false when using the “===” operator.

[Learn more](https://javascript.info/comparison)

# 3\. What are the ways to declare a variable?

There are 4 ways to declare a variable:

There are 4 ways to declare a variable:

![](https://miro.medium.com/v2/resize:fit:875/1*9TTze8sbyx9IDhTD-w5sKA.png)

Declaring a variable using the `var` keyword is similar to older methods of declaring variables in JavaScript. Variables declared this way have **function scope** if declared within a function and **global scope** if declared outside of any function. However, they lack **block scope**, which can lead to unintended behaviors in code.

In contrast, `let` and `const` are preferable for declaring variables. Both have **block scope**, meaning a variable declared inside a block (e.g., within a function, loop, or conditional statement) will not be accessible outside of that block.

The `const` keyword is used to declare variables that are immutable, meaning the variable itself cannot be reassigned. However, if a `const` variable is an object or an array, you can still modify the properties of the object or the elements of the array.

[Learn more](https://javascript.info/variables)

# 4\. What is the difference between null and undefined?

Both options represent an empty value. If we initialize a variable but don’t assign a value to it, it will be assigned a special marker — undefined. Null is assigned manually.

Null is a special value that represents “nothing,” “empty,” or “unknown value.” If we need to clear the value of a variable, we set foo = null.

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/null)

# 5\. Arrow functions and the differences from regular functions.

1.  Arrow functions cannot use the arguments object.
2.  They have a different syntax.
3.  Arrow functions do not have their own this context. When referencing this, an arrow function takes the context from the surrounding scope.
4.  Arrow functions cannot be used as constructor functions. In other words, they cannot be invoked with the new keyword.

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

# 6\. What is a closure and why are they needed?

A closure is a feature in JavaScript where a function retains access to variables from its lexical scope even after the function has finished executing. Essentially, when an inner function is defined within an outer function, it forms a closure by ‘closing over’ the variables of the outer function. This allows the inner function to continue accessing and manipulating those variables even after the outer function has returned.

![](https://miro.medium.com/v2/resize:fit:875/1*GdpgSS8I30GOcn1etd72ow.png)

[Learn more](https://javascript.info/closure)

# 7\. What are template literals?

Template literals are enclosed in backticks (\`\`) and allow for multiline strings. They also allow for embedding expressions within them.

![](https://miro.medium.com/v2/resize:fit:875/1*f9Fm-jA1K91rY495SdUOWw.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)

# 8\. What are Set and Map?

Map is a collection, a data structure that operates on the principle of key-value pairs, similar to Objects. However, the main difference between Map and Object is that Map allows the use of keys of any type.  
Set is a type of collection without keys, an array where each value can only appear once. Set stores unique values within itself.

[Learn more](https://javascript.info/map-set)

# 9\. How to check for the presence of a property in an object?

The first way is to use the hasOwnProperty function, which is available for every object.  
The second way is to use the in operator. However, when using the in operator, caution must be exercised as it checks all prototypes in the chain.

![](https://miro.medium.com/v2/resize:fit:875/1*xYk7CWllFOOWh9EIYd806w.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)

# 10\. How to access an object property?

The first way is static, using dot notation: obj.a.  
The second way is dynamic, using square brackets: obj\[‘a’\].

![](https://miro.medium.com/v2/resize:fit:875/1*gK6nW2HgAsNtCO2nwB8KXg.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects)

# 11\. What are the main methods for working with arrays?

-   forEach — an iterative method for looping through the array, does not return anything. It offers a more elegant alternative to a regular for loop.
-   filter(callback, \[args\]) — a method for filtering an array using a provided function. It creates a new array that includes only the elements from the original array for which the callback(item, i, arr) function returns true.
-   map(callback, \[args\]) — a method for transforming an array. It creates a new array that consists of the results of calling the callback(item, i, arr) function for each element of the array.
-   reduce(callback, \[initValue\]) — a method for sequentially processing each element of the array while maintaining an intermediate result.

[Learn more](https://javascript.info/array-methods)

# 12\. What are the ways to create an object?

Using a constructor function:

![](https://miro.medium.com/v2/resize:fit:875/1*vJFxy5bT2V3mjReTY2Ybfw.png)

Using object literal notation:

![](https://miro.medium.com/v2/resize:fit:875/1*5FrwaopNpFFfeCJ6s91U8Q.png)

Using a class:

![](https://miro.medium.com/v2/resize:fit:875/1*sEcAaWg9xZ9jDOFs72oApg.png)

Using the create function:

![](https://miro.medium.com/v2/resize:fit:875/1*O25N3YRqgJVIr-5oAKHJAg.png)

# 13\. What is a Promise?

A Promise is an object designed to work with asynchronous code. It maintains its own state. Initially, a Promise is in the pending state, then it transitions to the fulfilled state if the asynchronous code is executed successfully, or to the rejected state if an error occurs. A Promise accepts two callback functions:

-   onFulfilled, which is triggered when the Promise is fulfilled.
-   onRejected, which is triggered when the Promise is rejected.

The usage pattern is as follows:

1.  The code that needs to perform something asynchronously creates a Promise and returns it.
2.  The external code, upon receiving the Promise, passes the onFulfilled and onRejected callback functions to it.
3.  Upon completion of the process, the asynchronous code transitions the Promise to the fulfilled or rejected state, automatically invoking the corresponding callback function.

[Learn more](https://javascript.info/promise-basics)

# 14\. What is async/await and how to use it?

async/await is a special syntax for working with Promises.  
A function declared with the async syntax always returns a Promise.  
The keyword await makes the JavaScript interpreter wait until the Promise on the right side of await is fulfilled before continuing the execution. It will then return the result, and the code execution will proceed. await cannot be used in regular functions.

[Learn more](https://javascript.info/async-await)

# 15\. How to check if an object is an array?

To check whether an object is an array or not, you can use the Array.isArray() method. It takes an object as input and returns true if the object is an array, and false if it is not an array.

![](https://miro.medium.com/v2/resize:fit:875/1*phJsNkOCgbpjDTz-k-0EIw.png)

# 16\. What is the purpose of the spread operator?

The spread operator (…) is used to unpack arrays or objects.  
It allows you to expand elements that are iterable, such as arrays and strings.

-   It is used in functions where the expected number of arguments for a call is zero or more.
-   It is used in array literals or expressions.
-   It is used in object literals where the number of key-value pairs should be zero or more.

![](https://miro.medium.com/v2/resize:fit:875/1*vIrc5n9IWnwVkpHNAjvQEg.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)

# 17\. How to avoid reference dependency when copying an object?

If the object does not contain nested objects, for example:

![](https://miro.medium.com/v2/resize:fit:875/1*86wKZ5rXznUp9pxNwYmxaw.png)

In this case, you can use **spread operator** or **Object.assign()** method:

![](https://miro.medium.com/v2/resize:fit:875/1*BEM_DGPwj1l9Fsbl2jcvdg.png)

If the object contains nested objects:

![](https://miro.medium.com/v2/resize:fit:875/1*_xpmX3Br6wKgbTmbLzSy1Q.png)

In this case, you need to perform a deep copy.  
A workaround, though **slower**, is:

![](https://miro.medium.com/v2/resize:fit:875/1*SxNfj0tVgSdVFNxASeyTyQ.png)

This method is suitable for objects without prototypes and functions.  
Alternatively, you can use the lodash library’s **deepClone()** function.

# 18\. How to change the context of a function?

1.  Using the **bind()** method, which returns a new function with the bound context.

![](https://miro.medium.com/v2/resize:fit:875/1*o25EEiSKJdc3CLdsZ5nsfw.png)

1.  Using **call()** and **apply()** methods. The main difference is that **call()** accepts a sequence of arguments, while **apply()** accepts an array of arguments as the second parameter.

![](https://miro.medium.com/v2/resize:fit:875/1*MKoPKuewo22CowebqT24sA.png)

# 19\. What is a ternary operator / **conditional operator**.?

A ternary operator is a shorthand notation for an if-else statement. The operator is represented by a question mark and a colon. It is called ternary because it is the only operator that takes three arguments.

Condition ? Expression\_1 : Expression\_2

![](https://miro.medium.com/v2/resize:fit:875/1*KEW4z8aXg-IpEA_37ExWOA.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)

# 20\. What is destructuring?

Destructuring is a syntax that allows us to unpack arrays and objects into multiple variables.

![](https://miro.medium.com/v2/resize:fit:875/1*3PUUO1NQKZqdV2b3TwLGFw.png)

[Learn more](https://javascript.info/destructuring-assignment)

# 21\. What is the DOM?

DOM stands for Document Object Model. It is a representation of an HTML document as a tree of tags.  
Example  
Each node in the DOM tree is an object.

![](https://miro.medium.com/v2/resize:fit:875/0*5G_at4gLGcrEuCl7.png)

The basic elements of an HTML document are tags.  
According to the Document Object Model (DOM), each HTML tag is an object. Nested tags are “children” of their parent element. The text inside a tag is also an object. All these objects are accessible using JavaScript, and we can use them to manipulate the page.

[Learn more](https://javascript.info/dom-nodes)

# 22\. What is the Event Loop?

Event loop — a mechanism that manages the execution of code. It handles event processing and task execution in the correct order. The main idea of the event loop is that JavaScript runs in a single-threaded environment but can handle asynchronous operations. When an asynchronous operation, such as a server request, completes, it puts the corresponding event into the event queue. The event loop works in a loop, processing these events in the order they arrive. It takes an event from the queue and passes it for execution. If the event contains a callback or a handler, it is invoked, and the code associated with that event is executed. The event loop also handles other tasks, such as timers and microtasks (Promise). It manages the execution order of all these tasks to ensure consistency and prevent the blocking of the main thread of code execution.

In short, the event loop in JavaScript manages asynchronous operations by handling events in the queue and executing the corresponding code in the correct order. This allows JavaScript to be responsive and effectively utilize its resources when working with asynchronous operations.

![](https://miro.medium.com/v2/resize:fit:875/0*9ZbiKJ0EM31GDXNX.png)

I highly recommend watching the video at the link provided, as the topic is important and deserves a separate article.

[Learn more](https://www.youtube.com/watch?v=8aGhZQkoFbQ&t=15s&ab_channel=JSConf)

# 23\. What is prototypal inheritance?

Every object in JavaScript has a property — a prototype. Methods and properties can be added to the prototype. Other objects can be created based on the prototype. The created object automatically inherits the methods and properties of its prototype. If a property is absent in the object, its search will be performed in the prototype.  
[Learn more](https://javascript.info/prototype-inheritance)

# 24\. What is the Optional Chaining operator?

The Optional Chaining operator ?. stops the evaluation and returns undefined if the part after ?. is either undefined or null.

Let’s consider a user object. Most users have an address user.address, with a street user.address.street, but some users have not provided an address. In such cases, the Optional Chaining operator can help us avoid an error when trying to access the user’s street who hasn’t specified one in their address.

![](https://miro.medium.com/v2/resize:fit:875/1*KBNGf-8UB9deTz7hqKZjRg.png)

[Learn more](https://javascript.info/optional-chaining)

# 25\. What is Shadow DOM?

Shadow DOM is a set of web standards that allows for encapsulating the structure and styles of elements on a web page. It represents a special segment of the DOM that resides inside an element and is separate from the rest of the page. Shadow DOM is used to create components and widgets with isolated and stylized content that does not conflict with the overall structure of the page.  
[Learn more](https://javascript.info/shadow-dom)

# 26\. What is recursion? How to use it?

Recursion is an approach to problem-solving where a function solves a problem by reusing itself within its own function body. In simple terms, it’s when a function calls itself.

A recursive function consists of:

1.  Termination condition or base case
2.  Recursive step — a way to reduce the problem into simpler forms.

![](https://miro.medium.com/v2/resize:fit:875/1*VP1M4IsEI5ERGOUFSHCA7w.png)

The base case is a necessary condition; otherwise, it will lead to stack overflow due to an infinite loop of function calls.  
[Learn more](https://javascript.info/recursion)

# 27\. What’s the difference between Function Expression and Function Declaration?

Function Declaration is the traditional way of declaring a function.

![](https://miro.medium.com/v2/resize:fit:875/1*PWs2lax4hCxuhAoyakYlZw.png)

Function Expression:

![](https://miro.medium.com/v2/resize:fit:875/1*SpLynR8X3AwBh1tWQtPjMQ.png)

With Function Declaration, the function is created and assigned to a variable, just like any other value. Essentially, it doesn’t matter how the function is defined, as it is a value stored in the variable “foo”. Function Declarations, however, are processed before the code block is executed, meaning that they are visible throughout the entire code block. On the other hand, Function Expressions are created only when the execution flow reaches them.

[Learn more](https://javascript.info/function-expressions)

# 28\. What are constructor functions?

Constructor functions are regular functions that are used to create objects. However, there are two rules for using them:

1.  The name of the constructor function should start with a capital letter.
2.  The constructor function should be called using the new operator.

![](https://miro.medium.com/v2/resize:fit:875/1*dGrlUq53AgVlchTu2NLPYg.png)

When a constructor function is created using the new operator, the following happens:

1.  A new empty object is created and assigned to this.
2.  The code inside the constructor function is executed. Typically, this code will modify the this object and add new properties.
3.  The value of this is returned.

[Learn more](https://javascript.info/constructor-new)

# 29\. How can you get a list of keys and a list of values from an object?

You can use Object.keys() to get a list of keys and Object.values() to get a list of values.

![](https://miro.medium.com/v2/resize:fit:875/1*2Zx9Hma7YzS7iCHxwxNxjQ.png)

[Learn more](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

# 30\. Provide an example of new functionality in ES6.

The most common ones:

-   let and const. Introduction of new keywords let and const for declaring variables with block scope.
-   Arrow functions. The concept of arrow functions allows for more concise and clear function definitions.

![](https://miro.medium.com/v2/resize:fit:875/1*GWN0bHWpy7TVj-Vz0TKyOw.png)

-   Default parameters. You can define default values for function parameters.

![](https://miro.medium.com/v2/resize:fit:875/1*M7OITkxh2rIFKN1lPxU_zg.png)

-   Spread operator (…). The spread operator allows unpacking array or object elements for function arguments or creating new arrays/objects.

![](https://miro.medium.com/v2/resize:fit:875/1*fWFl41dfuo0HT1CoaBArNQ.png)

-   Destructuring. Destructuring allows extracting values from arrays or objects and assigning them to variables.

![](https://miro.medium.com/v2/resize:fit:875/1*OCaBufTUszETwxPTnnzJkg.png)

[Learn more](https://www.w3schools.com/js/js_es6.asp)

# 31\. How to do class inheritance in ES6?

Class inheritance is done using the “extends” keyword followed by the name of the parent class.

![](https://miro.medium.com/v2/resize:fit:875/1*v--iovTJyQ_ZCNlOXweKyw.png)

[Learn more](https://javascript.info/class)  
[And even more](https://javascript.info/class-inheritance)

# 32\. What are micro and macro tasks in JavaScript?

In JavaScript, microtasks and macrotasks refer to types of tasks that need to be executed in the event loop. Microtasks are tasks that need to be executed within the current event loop before the browser repaints the page. They are usually added to the execution queue using methods such as Promise.then(), process.nextTick() (in Node.js), or MutationObserver. Examples of microtasks include executing promise handlers and DOM mutations. On the other hand, macrotasks are tasks that need to be executed after the current event loop is finished and before changes are rendered on the screen. This includes tasks added to the event queue using setTimeout, setInterval, requestAnimationFrame, as well as handling input events and network requests. Macrotasks are executed after all microtasks in the current event loop have been processed. The difference between microtasks and macrotasks is important because it determines the order of execution and allows for managing the priority of different tasks in JavaScript. Microtasks have a higher priority and are executed before macrotasks, which allows for faster interface updates and prevents blocking the main JavaScript execution thread.  
[Learn more](https://javascript.info/event-loop)

# 33\. What are generators?

Generators produce a sequence of values one by one as needed. Generators work well with objects and make it easy to create data streams.

To declare a generator, a special syntax is used — a generator function.

![](https://miro.medium.com/v2/resize:fit:875/1*L0QPMWViuIFnukKtbgbzaQ.png)

next() is the main method of a generator. When called, next() starts executing the code until the nearest yield statement. The value may be absent, in which case it is represented as undefined. When a yield is reached, the function execution is paused, and the corresponding value is returned to the outer code.

![](https://miro.medium.com/v2/resize:fit:875/1*wMMQ9U_-omuY7NJkOZ2UHA.png)

[Learn more](https://javascript.info/generators)

# 34\. What are the methods of storing data in a browser?

There are several methods of storing data in a browser:

-   LocalStorage and SessionStorage — store key-value pairs in the browser. The data stored in them is retained after the page is refreshed. Both storage options can only use strings as keys and values, so objects need to be converted using JSON.stringify().
-   Cookie — small strings of data that are stored in the browser. Cookies are usually set by the web server using the Set-Cookie header. The browser will then automatically add them to almost every request to the same domain using the Cookie header. One cookie can hold up to 4kb of data. Depending on the browser, more than 20 cookies per site are allowed.
-   IndexedDB — a built-in database, more powerful than localStorage. It is a key-value store where multiple types of keys are available and values can be almost anything. IndexedDB supports transactions for reliability, supports key range queries and indexes, and allows storing more data than localStorage. IndexedDB is designed for offline applications and can be combined with Service Workers and other technologies.

[Learn more](https://javascript.info/localstorage)  
[Learn more](https://javascript.info/cookie)  
[Learn more](https://javascript.info/indexeddb)

# 35\. What is the difference between sessionStorage and localStorage?

SessionStorage and localStorage allow storing objects in key-value format in the browser.  
The main differences are:

-   localStorage can store up to 10 MB of data, while sessionStorage can store up to 5 MB.
-   Data in localStorage is not deleted, while data in sessionStorage is deleted when the browser tab is closed.
-   Data from localStorage is accessible from any window, while data from sessionStorage is only accessible from the same browser window.

[Learn more](https://javascript.info/localstorage)

# 36\. What are regular expressions?

Regular expressions are strings defined by special rules and patterns. They are a powerful tool that allows detecting and working with complex constructions within strings.

![](https://miro.medium.com/v2/resize:fit:875/1*leCnSAbkOwwx20immjxBQw.png)

[Learn more](https://javascript.info/regular-expressions)

# 37\. What are WeakSet and WeakMap and how do they differ from Map and Set?

The first difference between WeakMap and Map is that the keys in WeakMap must be objects, not primitive values.  
The second difference is in the memory storage of the data structures. The JavaScript engine keeps values in memory as long as they are reachable, meaning they can be used.  
Usually, object properties, array elements, or other data structures are considered reachable and are kept in memory as long as the data structure exists, even if there are no other references to them.  
In the case of WeakMap and WeakSet, it works differently. Once an object becomes unreachable, it is removed from the data structure.

[Learn more](https://javascript.info/weakmap-weakset)

# 38\. Why do two objects with the same fields return false when compared?

Objects are compared based on references to the memory area. For JavaScript, test1 and test2 objects are different, even though they have the same fields. Objects are only equal if they are the same object.

![](https://miro.medium.com/v2/resize:fit:875/1*VVZ2f7e5MxuVWNSGGenlZA.png)

# 39\. Why can we call methods on primitive types?

JavaScript allows working with primitive data types — strings, numbers, etc. — as if they were objects. Primitive data types have methods.  
To make this functionality available, each primitive data type has its own wrapper object: String, Number, Boolean, and Symbol. Thanks to these wrapper objects, primitive data types have different sets of methods, such as toLowerCase() or toUpperCase().

[Learn more](https://javascript.info/primitives-methods)

# 40\. How to check which class an object was created from?

You can check which class an object was created from using the **instanceof** operator, taking inheritance into account.

![](https://miro.medium.com/v2/resize:fit:875/1*CNzL4yA_DPPjdzKuHZsA9Q.png)

[Learn more](https://javascript.info/instanceof)

# 41\. Write code that will log the time spent on the site in seconds every 10 seconds.

![](https://miro.medium.com/v2/resize:fit:875/1*fwXOGWtrSE5Lc9bArYY1MA.png)

[Learn more](https://javascript.info/settimeout-setinterval)

# 42\. What is a pure function?

A pure function is a function that satisfies two conditions:

1.  Every time the function is called with the same set of arguments, it returns the same result.
2.  It has no side effects, meaning it does not modify variables outside the function.

![](https://miro.medium.com/v2/resize:fit:875/1*_1WdwSJCLWHWX5lZeylPiQ.png)

# 43\. What is a higher-order function?

A higher-order function is a function that takes another function as an argument or returns a function as a result.

![](https://miro.medium.com/v2/resize:fit:875/1*tqycavQ5MVMFHLP3mlJ6Gg.png)

# 44\. Why do we need Promises if we can work with asynchronous code using callbacks?

If we want to asynchronously fetch some data from a server using callback functions, it would result in the following:

![](https://miro.medium.com/v2/resize:fit:875/1*t8l4-7KccQf6aMuzU5RAvA.png)

This is called **callback hell**, as each callback is nested inside another, and each inner callback depends on the parent function.

Using Promises, we can rewrite the code above:

![](https://miro.medium.com/v2/resize:fit:875/1*2KDO49DFtlBiPgUizGXuXw.png)

With Promises, the execution sequence is clear, making the code more readable.  
[Learn more](https://javascript.info/promise-basics)

# 45\. Write your own implementation of the bind method.

To implement it, we can use closure and the apply() method to bind the function to the context.

![](https://miro.medium.com/v2/resize:fit:875/1*sk5h_Hq3jSlBEgC73Uod3A.png)

# 46\. Write a calculator function with methods plus, minus, multiply, divide, and get. The function must work through optional chaining.

![](https://miro.medium.com/v2/resize:fit:875/1*Ddrb6taodsonPYUZeE0Olw.png)

# 47\. Write a randomSort function that takes an array of numbers and sorts the array in random order.

You can use the sort() method and Math.random() for this.

![](https://miro.medium.com/v2/resize:fit:875/1*-BfyMUIuhNfILfH-EVeQCA.png)

# 48\. Write a deleteGreatestValue function that takes a two-dimensional array of numbers and removes the greatest number from each nested array.

We should iterate through every nested array, get the greatest value of each nested array and delete it.

![](https://miro.medium.com/v2/resize:fit:875/1*4dIuEC057vwud6-Emwzj4Q.png)

# 49\. Write a sortPeople function that takes an array of strings names and an array of numbers heights, where names\[i\] == heights\[i\]. It should sort the names array based on the heights array.

![](https://miro.medium.com/v2/resize:fit:875/1*6TQdIPCikg5OUND8duhO5w.png)

# 50\. Write a subsets function that takes an array of numbers nums and returns all possible variations of arrays from those numbers.

![](https://miro.medium.com/v2/resize:fit:875/1*ggmRMrqBiHvOFuzu4mi6tA.png)

# 51\. How to reverse a linked list?

Lets create a function reverseLinkedList that takes a linked list as input and returns the reversed version of that list.

Approach:

1.  It initializes the result variable with null, which will hold the reversed list.
2.  It initializes the root variable with head, which points to the start of the list.
3.  It enters a while loop that continues until root becomes null, indicating the end of the list.
4.  Inside the loop, it checks if result already has elements. If it does, it creates a new list node with the current value root.val and a pointer to the next node result. It then updates result with this new node.
5.  If result doesn’t have any elements yet, it creates a new list node with the current value root.val and null as the pointer to the next node. It then updates result with this new node.
6.  After updating result, it moves to the next element in the list by assigning root.next to root.
7.  Once the while loop finishes, it returns the reversed list stored in result.

In summary, the function reverses the linked list by iterating through each node from the head to the tail, creating a new list node for each value and updating the pointers accordingly.

![](https://miro.medium.com/v2/resize:fit:875/1*21n416p6nVZzqZmihUMqVw.png)

# 52\. How to sort a linked list?

Lets create a function sortList that takes a linked list as input and returns the sorted version of that list.

Approach:

1.  Check if the given linked list is empty or not.
2.  Traverse the linked list and store the node values into an array.
3.  Sort the array using the built-in sort() method.
4.  Create a new linked list using the sorted array.
5.  Return the head of the created linked list.

![](https://miro.medium.com/v2/resize:fit:875/1*IxObe8BfVyP1Mhpvay6v9Q.png)

# 53\. What’s the difference between observables and promises?

Observables and Promises are both used for handling asynchronous operations in JavaScript. A key difference is that Observables can emit multiple values over time. They are suitable for handling streams of data, such as user interactions, events, or data from APIs that change over time. Promises on the other hand can only resolve once with a single value. They are suitable for handling single asynchronous operations that will either succeed or fail.

In summary, Promises are best suited for handling one-time asynchronous operations with a single result, while Observables are more powerful when dealing with ongoing streams of data, events, and complex data processing pipelines. The choice between them depends on the specific use case and the nature of the asynchronous operations you’re dealing with.

[Learn More](https://codingbootcamps.io/resources/observables-vs-promises-whats-the-difference/)

# Conclusion

Preparing for these questions, studying the topics covered, and reviewing relevant resources can improve your chances of successfully passing the interview. This post is part of a series of posts on interview questions.

I look forward to your reactions and comments.  
Good luck in your interview!

## Embedded Content
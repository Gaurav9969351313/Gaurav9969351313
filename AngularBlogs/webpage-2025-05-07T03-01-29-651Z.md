# @ConditionalOnProperty Annotation in Spring Boot | by Ionut Anghel | Level Up Coding

# @ConditionalOnProperty Annotation in Spring Boot

## Leverage Spring Boot’s `@ConditionalOnProperty` for dynamic feature toggling and environment-specific configuration.

[

![Ionut Anghel](https://miro.medium.com/v2/resize:fill:64:64/1*Rie1ppKcKx8SyrhbfPdUGg.jpeg)





](https://medium.com/@ionut-anghel?source=post_page---byline--01234f6d2866---------------------------------------)

[Ionut Anghel](https://medium.com/@ionut-anghel?source=post_page---byline--01234f6d2866---------------------------------------)

Follow

6 min read

·

Oct 7, 2024

65

Listen

Share

More

![](https://miro.medium.com/v2/resize:fit:875/0*SdxpaNqZ7WbC6e1C)
Markus Spiske — Unsplash

**Spring Boot** is a powerful framework that simplifies application development by providing out-of-the-box features like auto-configuration, dependency injection, and property-based configurations. One of the key features of Spring Boot is the ability to conditionally enable or disable certain beans or configurations based on specific properties. The `@ConditionalOnProperty` annotation plays a crucial role in this context, providing developers with fine-grained control over which components to activate based on the presence or value of properties.

In this article, we will explore the `@ConditionalOnProperty` annotation in depth, including how it works, when and why you should use it, and common use cases. We’ll also cover some potential pitfalls, alternatives, and best practices.

# 1\. What is the `@ConditionalOnProperty` Annotation?

The `@ConditionalOnProperty` annotation is a part of the **Spring Boot autoconfiguration mechanism**. It allows developers to conditionally enable or disable Spring beans or configuration classes based on specific property values defined in the application's properties file (e.g., `application.properties` or `application.yml`).

In simple terms, if a property is set to a certain value, or even if it simply exists, Spring Boot will conditionally instantiate a bean or apply configuration. If the property doesn’t exist or doesn’t match the expected value, the configuration or bean will be skipped.

This annotation is particularly useful for managing application configurations that need to adapt based on external factors, such as environment settings (e.g., dev, test, or prod) or feature toggles.

# 2\. When and Why Should You Use `@ConditionalOnProperty`?

There are multiple scenarios where `@ConditionalOnProperty` becomes incredibly useful, such as:

-   **Feature Toggles:** You might have features that should be enabled or disabled based on whether a specific property is set. This is especially useful when developing new features that you want to toggle on and off during testing or for specific environments.
-   **Environment-Specific Configurations:** Different environments (development, testing, production) often require different beans or configurations to be active. Using `@ConditionalOnProperty`, you can activate specific features or beans for only certain environments.
-   **External Integrations:** Sometimes, your application may interact with external services, and you want to enable the associated beans or services only if the necessary configurations (like URLs, tokens, etc.) are present.

# 3\. Syntax and Usage

The syntax for using the `@ConditionalOnProperty` annotation is relatively straightforward. Here’s a basic example to illustrate how it works:

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;  
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;

@Configuration  
public class MyFeatureConfiguration {  
    @Bean  
    @ConditionalOnProperty(  
        name = "feature.myFeature.enabled",  
        havingValue = "true",  
        matchIfMissing = false  
    )  
    public MyFeatureBean myFeatureBean() {  
        return new MyFeatureBean();  
    }  
}

Let’s break down what’s happening here:

-   **name:** This is the key of the property that Spring will look for in the application properties file (e.g., `application.properties` or `application.yml`). In this case, it's `"feature.myFeature.enabled"`.
-   **havingValue:** This specifies the value that the property must have for the bean to be instantiated. In this example, the bean `myFeatureBean()` will only be instantiated if the property `feature.myFeature.enabled` is set to `"true"`.
-   **matchIfMissing:** This is a boolean flag that controls what happens if the property is not defined in the properties file. If `matchIfMissing` is `true`, the bean will be instantiated even if the property is absent. If `false` (as in the example above), the bean will only be created if the property exists **and** has the value `"true"`.

# 4\. Real-World Use Cases

Here are a few real-world scenarios where you might want to use `@ConditionalOnProperty`:

# 4.1. Feature Flags

Consider you’re developing a new feature, but you only want it to be enabled in specific environments or under certain conditions. Using `@ConditionalOnProperty`, you can achieve this easily.

**application.properties:**

feature.myFeature.enabled\=true

**Configuration:**

@Configuration  
public class MyFeatureConfig {

@Bean  
    @ConditionalOnProperty(name = "feature.myFeature.enabled", havingValue = "true")  
    public MyFeatureService myFeatureService() {  
        return new MyFeatureService();  
    }  
}

When `feature.myFeature.enabled` is set to `"true"`, `myFeatureService` will be instantiated. If set to `"false"` or not set at all, the bean won't be created.

# 4.2. Environment-Specific Beans

In a microservice environment, different environments may require distinct configurations. For example, in a dev environment, you might want to use a mock service, while in production, you would use the actual implementation.

**application-dev.properties:**

email.service.enabled\=true

**application-prod.properties:**

email.service.enabled\=false

**Configuration:**

@Configuration  
public class EmailServiceConfig {

@Bean  
    @ConditionalOnProperty(name = "email.service.enabled", havingValue = "true")  
    public EmailService emailService() {  
        return new RealEmailService();  
    }  
    @Bean  
    @ConditionalOnProperty(name = "email.service.enabled", havingValue = "false", matchIfMissing = true)  
    public EmailService mockEmailService() {  
        return new MockEmailService();  
    }  
}

In the **dev environment**, `RealEmailService` will be instantiated, while in **prod**, `MockEmailService` will be used.

# 5\. Combining `@ConditionalOnProperty` with Other Conditional Annotations

Spring provides several other conditional annotations that can be used alongside `@ConditionalOnProperty` for more complex use cases. Here are a few examples:

# 5.1. `@ConditionalOnMissingBean`

Sometimes, you want to instantiate a bean only if another bean doesn’t exist. You can combine `@ConditionalOnProperty` with `@ConditionalOnMissingBean` for this:

@Bean  
@ConditionalOnProperty(name = "feature.payment.enabled", havingValue = "true")  
@ConditionalOnMissingBean(PaymentService.class)  
public PaymentService paymentService() {  
    return new PaymentServiceImpl();  
}

This bean will be created only if the property `feature.payment.enabled` is `true` and no other `PaymentService` bean exists.

# 5.2. `@ConditionalOnClass`

You might also want to conditionally instantiate a bean only if a certain class is present on the classpath:

@Bean  
@ConditionalOnProperty(name = "feature.payment.enabled", havingValue = "true")  
@ConditionalOnClass(name = "com.example.PaymentGateway")  
public PaymentService paymentService() {  
    return new PaymentServiceImpl();  
}

Here, the `PaymentService` bean will only be instantiated if the property is `true` **and** the `PaymentGateway` class exists on the classpath.

# 6\. Common Challenges and Best Practices

While `@ConditionalOnProperty` is very powerful, it can introduce complexity if not used carefully. Here are some best practices and common pitfalls to watch out for:

# 6.1. Overusing Conditional Beans

Using too many conditionals can make your configuration hard to read and maintain. It’s important to use conditionals judiciously. If your conditions are becoming too complex, consider refactoring or breaking your configurations into smaller, more manageable pieces.

# 6.2. Testing Conditional Configurations

Testing beans that are conditionally instantiated can be tricky. You may need to simulate different environments or override property values during tests to ensure all conditions are covered. Spring’s `@TestPropertySource` can help in these cases:

@RunWith(SpringRunner.class)  
@SpringBootTest  
@TestPropertySource(properties = "feature.myFeature.enabled=true")  
public class MyFeatureServiceTest {

@Autowired  
    private MyFeatureService myFeatureService;  
    @Test  
    public void testMyFeatureIsEnabled() {  
        assertNotNull(myFeatureService);  
    }  
}

# 6.3. Property Naming Conventions

To avoid confusion and conflicts, it’s best to adopt a clear and consistent naming convention for your properties. Group related properties together and prefix them with meaningful names, such as `feature.*` or `service.*`.

# 6.4. Documentation and Communication

Conditional configurations can make the application behavior less predictable, especially for new developers joining the team. It’s important to document the purpose of each conditional bean and how properties should be used.

# 7\. Alternatives to `@ConditionalOnProperty`

While `@ConditionalOnProperty` is very useful, there are other mechanisms in Spring that can achieve similar outcomes:

# 7.1. Profiles

Spring Profiles provide a way to configure beans for specific environments (e.g., dev, test, prod) using the `@Profile` annotation. This can sometimes be

more appropriate than using `@ConditionalOnProperty`.

@Bean  
@Profile("dev")  
public MyService devService() {  
    return new DevService();  
}

@Bean  
@Profile("prod")  
public MyService prodService() {  
    return new ProdService();  
}

Profiles are great for environment-specific beans but lack the fine-grained control that `@ConditionalOnProperty` offers for feature toggles and property-based conditions.

# 7.2. Custom Conditional Annotations

Spring allows you to create custom conditional annotations by extending the `Condition` interface. This provides even greater flexibility and can be useful for more complex scenarios.

@Target({ ElementType.TYPE, ElementType.METHOD })  
@Retention(RetentionPolicy.RUNTIME)  
@Conditional(MyCustomCondition.class)  
public @interface ConditionalOnCustomLogic {  
    // Custom logic  
}

# 8\. Conclusion

The `@ConditionalOnProperty` annotation is a powerful tool in Spring Boot that gives developers control over which beans or configurations should be enabled or disabled based on the presence or value of specific properties. This can be incredibly useful for feature toggles, environment-specific configurations, and more.

When used properly, `@ConditionalOnProperty` can simplify application configuration by making it more dynamic and flexible. However, it’s essential to use it judiciously and in combination with other Spring features, like profiles and other conditional annotations, to ensure that your application remains maintainable and understandable.

By following best practices and understanding the potential pitfalls, you can leverage `@ConditionalOnProperty` to create more adaptable and configurable Spring Boot applications.

## Embedded Content
# I failed a $190,000 FrontEnd Interview due to this try…catch question! | by Tech Virtuoso | Towards Dev

Member-only story

# I failed a $190,000 FrontEnd Interview due to this try…catch question!

[

![Tech Virtuoso](https://miro.medium.com/v2/resize:fill:64:64/1*UhOBDUYvOTUrDkugZYu4NA.png)





](https://medium.com/@techvirtuoso?source=post_page---byline--a7ae85812c0d---------------------------------------)

[Tech Virtuoso](https://medium.com/@techvirtuoso?source=post_page---byline--a7ae85812c0d---------------------------------------)

Follow

3 min read

·

Feb 7, 2024

1.6K

35

Listen

Share

More

![](https://miro.medium.com/v2/resize:fit:875/1*eo8HVH9ki6YMYg-jSubtnA.jpeg)

> Anyone can access my article; readers who are not members can follow this [link](https://medium.com/@techvirtuoso/i-failed-a-190-000-frontend-interview-due-to-this-try-catch-question-a7ae85812c0d) to read the entire text.

I had a tech interview for a FrontEnd developer position with the annual salary of around $190,000, unfortunately I failed because I missed a `try…catch` question. Let me tell you what the question is, and maybe it can help you as well.

In JavaScript, the `try…catch` construct is often perceived as a safety net, a guardian against the perils of unexpected errors within code blocks. Many developers, including myself, have wielded it confidently in synchronous contexts. However, a seemingly innocuous question during an interview shattered my complacency, revealing a blind spot in my understanding: `try…catch` can only capture errors within synchronous code blocks.

# The Challenge

The interview question that tripped me up was deceptively simple: are there any issues with the code snippets below?

try {  
  setTimeout(() => {  
    throw new Error('err')  
  }, 200);  
} catch (err) {  
  console.log(err);  
}

and

try {  
  Promise.resolve().then(() => {  
    throw new Error('err')  
  })  
} catch (err) {  
  console.log(err);  
}

Confounded, I faltered. How could these snippets be problematic? After all, isn’t this a common pattern in coding? It was a stark reminder of the adage: familiarity breeds complacency.

# The Revelation

Post-interview, armed with humility, I delved into the nuances of `try…catch`. The epiphany struck hard: `try…catch` is ill-equipped to handle asynchronous errors because it operates synchronously. In JavaScript, `setTimeout`, a quintessential asynchronous function, schedules its callback to the event queue, decoupling it from the `try…catch` block’s execution.

# The Solution

To confront this limitation, one must embrace a paradigm shift in error handling within asynchronous contexts. The correct approach involves integrating error handling directly into asynchronous operations using callbacks, Promises, or the modern `async/await` syntax.

Consider the corrected version of the first snippet:

new Promise((resolve, reject) => {  setTimeout(() => {    try {      throw new Error('err');  
    } catch (err) {      reject(err);  
    }  
  }, 200);  
})  
  .then(() => {    // Handle successful execution  })  
  .catch((err) => {    console.log(err); // Error is caught here  });

And for the second snippet:

// Method One: Using Promise chaining  
Promise.resolve()  
  .then(() => {  
    throw new Error('err');  
  })  
  .catch((err) => {  
    console.log(err); // Error is caught here  
  });  
  
// Method Two: Using async/await  
async function handleError() {  
  try {  
    await Promise.resolve().then(() => {  
      throw new Error('err');  
    });  
  } catch (err) {  
    console.log(err); // Error is caught here  
  }  
}  
  
handleError();

These revised implementations demonstrate a proactive approach to error management in asynchronous scenarios, leveraging the intrinsic capabilities of Promises and `async/await`.

My journey from interview failure to enlightenment underscored the importance of continuous learning and humility in the ever-evolving landscape of software development. Embracing the nuances of error handling in JavaScript not only enriches our understanding but also equips us to write more robust and resilient code.

So, fellow developers, let us not shy away from confronting our misconceptions. For it is in acknowledging our weaknesses that we pave the path to mastery.

If you found this article helpful, please encourage me by giving it a clap. Follow me for more interesting articles on web development.

## Embedded Content

---
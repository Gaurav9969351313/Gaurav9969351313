# Angular Tree Shaking: A Comprehensive Guide | by abdelrhman osama | QuaNode | Mar, 2025 | Medium

Featured

# Angular Tree Shaking: A Comprehensive Guide

[

![abdelrhman osama](https://miro.medium.com/v2/da:true/resize:fill:64:64/0*RTe06O2LNrT-JKIy)





](/@abdelrhmanosaam?source=post_page---byline--05efa40c4604---------------------------------------)

[abdelrhman osama](/@abdelrhmanosaam?source=post_page---byline--05efa40c4604---------------------------------------)

Follow

6 min read

·

Mar 17, 2025

3

Listen

Share

More

![](https://miro.medium.com/v2/resize:fit:1250/1*EITidKX9moOpK8jZj4lHnQ.png)

Tree shaking is a **dead code elimination technique** to remove unused JavaScript code from the final bundle. In modern front-end frameworks like Angular, it is particularly crucial to improve performance by reducing bundle size.

Angular leverages tree shaking, static analysis, TypeScript, Ahead-of-Time (AOT) compilation, and Webpack optimizations to improve application performance, and ensure efficient dependency management. This guide will dive deep into these topics and illustrate how tree shaking works in Angular with practical examples.

## Understanding Tree-Shaking in Angular

Tree-shaking removes unused code from the final JavaScript bundle during the build process. Angular achieves this primarily through:

-   **Static Analysis:** Identifying unused imports and dependencies.
-   **Dead Code Elimination:** Removing functions, classes, or services that are not referenced.
-   **Optimized Compilation:** Generating smaller and more efficient JavaScript bundles.

Angular’s shift to the Ivy compiler has further improved tree-shaking by making service injection more dynamic and eliminating unnecessary module imports.

## Examples of Tree-Shaking in Angular

1.  **Removing Unused Services with** \*\* providedIn: ‘root’ \*\*

In older Angular versions, services were manually provided in the providers' array within NgModule, making them always available in the final bundle. However, with providedIn: ‘root’, Angular tree-shakes services that are never used.

**Without Tree-Shaking (Legacy Approach)**

import { NgModule } from '@angular/core';  
import { SomeService } from './some.service';  
  
@NgModule({  
 providers: \[SomeService\]  
})  
export class AppModule {}

-   **Issue:** Even if SomeService is never used, it remains included in the final bundle.

**With Tree-Shaking (Optimized Approach)**

import { Injectable } from '@angular/core';  
  
@Injectable({ providedIn: 'root' })  
export class SomeService {  
 constructor() {  
   console.log('SomeService Loaded');  
 }  
}

-   **Tree-Shaking Benefit:** If SomeService is never referenced, Angular removes it from the bundle.

**2\. Tree-Shaking Unused Functions in Modules**

If you have a module that exports multiple functions but only a few are used, tree-shaking removes the unused ones.

**Module with Multiple Functions**

export function usedFunction() {  
 console.log('This function is used');  
}  
export function unusedFunction() {  
 console.log('This function is never used');  
}

**Usage in a Component**

import { usedFunction } from './utils';  
usedFunction();

-   **Tree-Shaking Benefit:** unusedFunction() is never referenced, so Webpack removes it from the final build.

**3\. Tree-Shaking Unused Components in Angular**

When using lazy loading and feature modules, Angular eliminates unused components.

**Feature Module (UnusedComponent is not referenced anywhere)**

import { NgModule } from '@angular/core';  
import { CommonModule } from '@angular/common';  
import { UsedComponent } from './used.component';  
import { UnusedComponent } from './unused.component';  
  
@NgModule({  
 declarations: \[UsedComponent, UnusedComponent\],  
 exports: \[UsedComponent\]  
})  
export class FeatureModule {}

-   **Tree-Shaking Benefit:** Since UnusedComponent is never imported or used, Angular removes it during the build.

**4\. Tree-Shaking with Lazy Loading**

Tree-shaking works well with lazy-loaded modules by eliminating unused feature modules from the initial bundle.

**Lazy Loaded Module (FeatureModule is loaded only when needed)**

const routes: Routes = \[  
 { path: 'feature', loadChildren: () => import('./feature.module').then(m =>  
m.FeatureModule) }  
\];

-   **Tree-Shaking Benefit:** The FeatureModule is excluded from the main bundle and only loaded when necessary.

# How Angular Supports Tree Shaking Under The Hood

Angular applications utilize tree shaking in the following ways:

-   **AOT Compilation** eliminates unused Angular decorators and metadata before bundling.
-   **ES6 Modules** allow Webpack to analyze dependencies effectively.
-   **Webpack Optimization Plugins** remove dead code.
-   **TypeScript Compiler** helps ensure code is statically analyzable.

## **JIT vs. AOT Compilation and Their Impact on Tree-Shaking**

Angular supports two compilation modes:

1.  **JIT Compilation (The Old Way)**

JIT compilation is performed at runtime in the browser. Key characteristics include:

-   **Compilation at Runtime:** Angular compiles components and modules dynamically when the application loads.
-   **Larger Bundle Size:** The compiler itself is included in the final bundle, leading to a bloated size.
-   **Limited Tree-Shaking:** Due to dynamic dependencies, the bundler cannot determine which parts of the application can be safely removed.

**2\. AOT Compilation (The New Way with Ivy)**

With AOT, Angular compiles templates and dependencies during the build phase. Benefits include:

-   **Smaller Bundle Size:** The Angular compiler is removed from the production bundle.
-   **Enhanced Tree-Shaking:** AOT ensures unused components, services, and dependencies are eliminated before the final build.
-   **Faster Performance:** Precompiled templates lead to faster rendering and improved startup times.

## **Webpack’s Role in Angular’s JIT and AOT Compilation**

Webpack is a module bundler that plays a critical role in both JIT and AOT compilation in Angular. The way Webpack processes dependencies in these two modes differs significantly.

**Webpack with JIT Compilation (The Old Way)**

With JIT, Webpack includes all necessary dependencies, but because Angular compiles templates dynamically at runtime, Webpack cannot fully optimize the output.

**JIT Webpack Configuration Example**

{  
 "mode": "development",  
 "entry": "./src/main.ts",  
 "output": {  
   "filename": "bundle.js"  
  },  
 "module": {  
   "rules": \[  
     {  
       "test": /\\.ts$/,  
       "use": "ts-loader",  
       "exclude": /node\_modules/  
     }  
   \]  
 }  
}

-   Webpack includes Angular’s compiler in the bundle.
-   Templates are compiled at runtime, leading to larger bundles.
-   Limited tree-shaking due to runtime dependency resolution.

**Webpack with AOT Compilation (The New Way with Ivy)**

With AOT, Angular compiles templates at build time, allowing Webpack to optimize the output more effectively.

**AOT Webpack Configuration Example**

{  
 "mode": "production",  
 "entry": "./src/main.ts",  
 "output": {  
   "filename": "bundle.min.js"  
  },  
 "module": {  
   "rules": \[  
     {  
       "test": /\\.ts$/,  
       "use": "@ngtools/webpack",  
       "exclude": /node\_modules/  
     }  
   \]  
 }  
}

-   Webpack uses the @ngtools/webpack loader to perform AOT compilation.
-   The Angular compiler is **not included** in the final bundle.
-   Tree-shaking is fully effective because templates are precompiled.

## Common Pitfalls That Prevent Tree Shaking

1.  Using \*\*require()\*\* Instead of \*\*import\*\*

-   Tree shaking works only with ES6 import statements, not with CommonJS require()

2\. Side Effects in Modules

-   Avoid side effects such as:

// side-effects.ts  
console.log("This module has a side effect!");  
export function usefulFunction() {  
 console.log("This function might be used somewhere");  
}

// main.ts  
import { usefulFunction } from "./side-effects";  
usefulFunction();

Even if usefulFunction is removed by tree shaking, the console.log(“This module has a side effect!”) will still execute, preventing the entire module from being removed.

-   A “side effect” is defined as code that performs a special behavior when imported, other than exposing one or more exports. An example of this is polyfills, which affect the global scope and usually do not provide an export.
-   If you are sure there are no side effects, you can mark modules as side-effect-free using Webpack configuration in package.json.

Example:

{  
 "sideEffects": false  
}

This tells Webpack that all files are pure (free of side effects), allowing aggressive tree shaking.

**3\. Dynamic Imports in a Non-Optimal Way**

-   Use lazy loading for modules instead of importing everything upfront:

loadChildren: () => import('./feature/feature.module').then(m =>  
m.FeatureModule)

## Importance of TypeScript with AOT and Ivy in Contrast to JIT

TypeScript plays a crucial role in Angular’s AOT compilation process, offering significant advantages over JavaScript by enabling **static typing, better tooling, and enhanced tree-shaking.**

**TypeScript and AOT: A Strong Combination**

-   TypeScript allows **static analysis**, making it easier for the AOT compiler to perform ahead-of-time optimizations.
-   Strong **type safety** reduces runtime errors, which is crucial for large-scale enterprise applications.
-   TypeScript’s support for **decorators and metadata reflection** integrates seamlessly with Angular’s dependency injection and module resolution system.

**JIT and Hybrid Applications: Mixing JavaScript and TypeScript**

JIT compilation allows developers to write hybrid applications that combine **both TypeScript and JavaScript** within the same project. This approach is particularly beneficial for:

-   **Gradual Migration:** Applications transitioning from JavaScript to TypeScript can mix both languages.
-   **Dynamic Code Execution:** JIT enables runtime template compilation, which can be useful in cases requiring dynamic component rendering.
-   **Rapid Prototyping:** Since JIT compiles in the browser, changes are reflected instantly without a full rebuild, making it ideal for debugging.

**Historical Context of TypeScript Adoption in Angular**

-   **Before TypeScript (AngularJS 1.x):** AngularJS applications were written purely in JavaScript, making them prone to runtime errors due to lack of type safety.
-   **Angular 2 and the TypeScript Shift (2016):** Google officially adopted TypeScript as the primary language for Angular, introducing better developer experience and improved maintainability.
-   **Integration with AOT (Angular 4+):** TypeScript-powered AOT compilation became the standard, leading to smaller and faster production builds.
-   **Ivy and Further TypeScript Optimizations (Angular 9+):** The Ivy renderer further enhanced TypeScript’s role by enabling better tree-shaking, lazy loading, and runtime efficiency.

**Comparing TypeScript with AOT vs. JavaScript with JIT**

![](https://miro.medium.com/v2/resize:fit:768/1*pkGbhhl0A7pSGj6Ni1iQNA.png)

## Conclusion

Tree shaking in Angular is a crucial optimization technique that relies on **static analysis, ES6 modules, AOT compilation, and Webpack optimizations.** By following best practices and understanding how Angular processes dependencies, developers can significantly reduce bundle sizes and improve application performance.

By leveraging tree-shakable providers ( providedIn: ‘root’ ) and component-level lazy loading, developers can build faster and more efficient Angular applications.

## Embedded Content
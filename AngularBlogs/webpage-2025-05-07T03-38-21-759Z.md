# Mastering Global Error Handling in Angular: A Comprehensive Guide | by M Business Solutions | JavaScript in Plain English

# Mastering Global Error Handling in Angular: A Comprehensive Guide

## How to Implement a Custom ErrorHandler to Enhance Application Stability and Maintainability

[

![M Business Solutions](https://miro.medium.com/v2/resize:fill:64:64/1*ARHBYAt-Z8iITtzLkJxYvg.jpeg)





](https://medium.com/@mbusinesssolutions?source=post_page---byline--de87b1a153eb---------------------------------------)

[M Business Solutions](https://medium.com/@mbusinesssolutions?source=post_page---byline--de87b1a153eb---------------------------------------)

Follow

5 min read

¬∑

Dec 20, 2024

1

Listen

Share

More

![](https://miro.medium.com/v2/resize:fit:875/0*Kqz_CtuKl9aSgAyH)

**üìñ Open for Everyone!**

My articles are accessible to all readers! Non-members can enjoy the full article by clicking this special link. Feel free to share it with others who might find it useful! üöÄ

[

## Mastering Global Error Handling in Angular: A Comprehensive Guide

### How to Implement a Custom ErrorHandler to Enhance Application Stability and Maintainability

medium.com



](https://medium.com/@mbusinesssolutions/mastering-global-error-handling-in-angular-a-comprehensive-guide-de87b1a153eb?source=post_page-----de87b1a153eb---------------------------------------)

**Introduction**  
In any complex application, errors and exceptions are inevitable. From network failures to unexpected data types, handling these issues gracefully can spell the difference between a smooth user experience and a cascade of disruptive crashes. Angular provides a built-in mechanism to handle errors globally through its `ErrorHandler` interface. By creating a global custom error handler, you gain a single entry point for dealing with all runtime errors, enabling you to log issues, display user-friendly messages, and integrate with external monitoring services‚Äîall without littering your codebase with ad-hoc try-catch statements.

In this blog, we‚Äôll explore the fundamentals of global error handling in Angular, learn how to implement a custom error handler as both a class and a function-based factory, and discover best practices to ensure your application is production-ready.

**Why Global Error Handling Matters**  
Without a centralized error-handling strategy, you risk scattering various approaches throughout your application: a console log here, a user alert there. This decentralization makes it difficult to maintain a consistent user experience and effectively track and fix errors. A global error handler allows you to:

1.  **Maintain Consistency:** Centralize how errors are handled across all components and services.
2.  **Improve Maintenance:** Streamline debugging and logging by ensuring all runtime errors are funneled through a single method.
3.  **Enhance Reliability:** Integrate with tools like Sentry, Datadog, or New Relic for real-time alerts and performance monitoring.
4.  **User-Friendly Messaging:** Gracefully communicate errors to the user with minimal disruption, improving UX and user trust.

**Implementing a Class-Based Custom Error Handler**  
Angular‚Äôs `ErrorHandler` is a simple interface with a single method signature:

handleError(error: any): void;

To implement a global error handler, you create a class that implements `ErrorHandler` and override this method:

**custom-error-handler.service.ts:(class approach)**

import { ErrorHandler, Injectable, isDevMode } from '@angular/core';  
  
@Injectable({  
  providedIn: 'root'  
})  
export class CustomErrorHandler implements ErrorHandler {  
  handleError(error: any): void {  
    // In dev mode, log the error to the console for debugging.  
    if (isDevMode()) {  
      console.error('An unexpected error occurred:', error);  
    }  
    // In production mode, integrate with an external logging service.  
    // Example: loggingService.logError(error);  
    // Optionally, you could display a user-friendly message or navigate to an error page.  
  }  
}  

**custom-error-handler.service.ts:(method approach)**

import { ErrorHandler, isDevMode } from '@angular/core';  
  
export function customErrorHandlerFactory(): ErrorHandler {  
  return {  
    handleError: (error: any): void => {  
      if (isDevMode()) {  
        console.error('An unexpected error occurred:', error);  
      }  
      // Integrate with external logging services in production  
      // loggingService.logError(error);  
    }  
  };  
}

**Registering the Handler in AppModule:**

import { NgModule, ErrorHandler } from '@angular/core';  
import { BrowserModule } from '@angular/platform-browser';  
import { AppComponent } from './app.component';  
import { CustomErrorHandler } from './custom-error-handler.service';  
  
@NgModule({  
  declarations: \[AppComponent\],  
  imports: \[BrowserModule\],  
  providers: \[  
    { provide: ErrorHandler, useClass: CustomErrorHandler }  
  \],  
  bootstrap: \[AppComponent\]  
})  
export class AppModule {}

import { NgModule, ErrorHandler } from '@angular/core';  
import { BrowserModule } from '@angular/platform-browser';  
import { AppComponent } from './app.component';  
import { customErrorHandlerFactory } from './custom-error-handler-factory';  
  
@NgModule({  
  declarations: \[AppComponent\],  
  imports: \[BrowserModule\],  
  providers: \[  
    { provide: ErrorHandler, useFactory: customErrorHandlerFactory }  
  \],  
  bootstrap: \[AppComponent\]  
})  
export class AppModule {}

After angular 14+

import { bootstrapApplication } from '@angular/platform-browser';  
import { provideHttpClient } from '@angular/common/http';  
import { ErrorHandler } from '@angular/core';  
import { AppComponent } from './app.component';  
import { CustomErrorHandler } from './custom-error-handler.service';  
  
bootstrapApplication(AppComponent, {  
  providers: \[  
    provideHttpClient(),  
    { provide: ErrorHandler, useClass: CustomErrorHandler }  
  \]  
}).catch(err => console.error(err));

With this configuration, any unhandled error thrown during the runtime of your Angular application will pass through your `CustomErrorHandler`. This includes template errors, component initialization issues, and errors from observable subscriptions that fail to catch exceptions downstream.

**Using a Function-Based Factory**  
If you prefer a more functional approach, Angular‚Äôs dependency injection system allows you to provide an `ErrorHandler` as a factory function rather than a class. This can be useful if you want a more lightweight syntax or if you‚Äôre integrating configuration dynamically.

**custom-error-handler-factory.ts:**

import { ErrorHandler, isDevMode } from '@angular/core';  
  
export function customErrorHandlerFactory(): ErrorHandler {  
  return {  
    handleError: (error: any): void => {  
      if (isDevMode()) {  
        console.error('An unexpected error occurred:', error);  
      }  
      // Integrate with external logging services in production  
      // loggingService.logError(error);  
    }  
  };  
}

**Registering the Factory in AppModule:**

import { NgModule, ErrorHandler } from '@angular/core';  
import { BrowserModule } from '@angular/platform-browser';  
import { AppComponent } from './app.component';  
import { customErrorHandlerFactory } from './custom-error-handler-factory';

@NgModule({  
  declarations: \[AppComponent\],  
  imports: \[BrowserModule\],  
  providers: \[  
    { provide: ErrorHandler, useFactory: customErrorHandlerFactory }  
  \],  
  bootstrap: \[AppComponent\]  
})  
export class AppModule {}

This functional approach offers the same benefits as a class-based handler, simply organized in a different style.

**Best Practices for Global Error Handling**

1.  **Differentiate Between Environments:**  
    Use Angular‚Äôs `isDevMode()` function to provide more verbose logging in development and silent logging in production.
2.  **Integrate with Logging/Monitoring Tools:**  
    Consider sending errors to services like Sentry, Rollbar, or LogRocket. This provides insights into the types and frequency of errors, and helps you prioritize fixes.
3.  **User-Friendly Error Notifications:**  
    Instead of leaving the user in the dark when errors occur, show a non-technical message explaining that something went wrong. A friendly modal or toast can guide the user on what to do next.
4.  **Graceful Degradation:**  
    For certain errors, consider fallback strategies. For example, if an API call fails, you might display cached data or allow the user to retry.
5.  **Avoid Over-Handling:**  
    While global error handling is powerful, don‚Äôt rely exclusively on it. In specific scenarios (e.g., form validation), it‚Äôs often better to handle errors locally and give immediate, contextual feedback to the user.

**Conclusion**  
Global error handling in Angular is a vital tool for building robust, stable, and maintainable applications. By implementing a custom `ErrorHandler`, you gain centralized control over how your application responds to runtime errors. Whether you choose a class-based or function-based approach, the key is to integrate logging, user-friendly messages, and external monitoring to ensure that when errors occur‚Äîbecause they eventually will‚Äîyou‚Äôre equipped to handle them gracefully and keep your users engaged.

Adopting these strategies early on will set you up for long-term success, making troubleshooting easier, maintaining code quality simpler, and ultimately delivering a better user experience.

## If you found this blog helpful, please give it a clap üëè and follow üîî for more insights and updates! Your support keeps the knowledge flowing!

# Thank you for being a part of the community

_Before you go:_

-   Be sure to **clap** and **follow** the writer Ô∏èüëè**Ô∏èÔ∏è**
-   Follow us: [**X**](https://x.com/inPlainEngHQ) | [**LinkedIn**](https://www.linkedin.com/company/inplainenglish/) | [**YouTube**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) | [**Newsletter**](https://newsletter.plainenglish.io/) | [**Podcast**](https://open.spotify.com/show/7qxylRWKhvZwMz2WuEoua0)
-   [**Check out CoFeed, the smart way to stay up-to-date with the latest in tech**](https://cofeed.app/) **üß™**
-   [**Start your own free AI-powered blog on Differ**](https://differ.blog/) üöÄ
-   [**Join our content creators community on Discord**](https://discord.gg/in-plain-english-709094664682340443) üßëüèª‚Äçüíª
-   For more content, visit [**plainenglish.io**](https://plainenglish.io/) + [**stackademic.com**](https://stackademic.com/)

## Embedded Content